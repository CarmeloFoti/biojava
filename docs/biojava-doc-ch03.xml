<!--DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
                      "file:///usr/share/sgml/docbook/xml-dtd/docbookx.dtd" [
]-->

<chapter id="bd-ch03">
    <title><classname>Sequence</classname>s and
    <classname>Feature</classname>s</title>

  <abstract id="bd-ch03-abstract">
    <para><xref linkend="bd-ch02"/> covered the
    <classname>SymbolList</classname> interface, BioJava's basic
    representation of biological sequence data. This chapter examines
    the <classname>Sequence</classname> interface. This adds extra
    functionality to <classname>SymbolList</classname>, providing a
    convenient way to handle annotated sequences from biological
    database. This chapter concentrates on classes and interfaces
    defined in the package
    <classname>org.biojava.bio.seq</classname>. For full descriptions
    of all the API used here, please consult the <ulink
    url="javadoc/index.html">JavaDoc documentation</ulink>.</para>
  </abstract>

  <sect1 id="bd-ch03-tour">
    <title>A tour of a <classname>Sequence</classname></title>

    <para><classname>Sequence</classname> is a sub-interface of
    <classname>SymbolList</classname>. Thus, all the standard methods
    for accessing sequence data in a <classname>SymbolList</classname>
    can equally be applied to a <classname>Sequence</classname>, and
    <classname>Sequence</classname>s can be passed to any analysis
    methods which normally expect to receive a
    <classname>SymbolList</classname>. The
    <classname>Sequence</classname> interface adds two types of
    additional data to a <classname>SymbolList</classname>.</para>

    <itemizedlist>
      <listitem>
        <para>Global annotations, such as names, database identifiers,
        and literature references.</para>
      </listitem>
      <listitem>
        <para>Location-specific annotations (features).</para>
      </listitem>
      </itemizedlist>

    <para>Two pieces of global annotation information are considered
    to be sufficiently important that they have dedicated accessor
    methods. The name of the <classname>Sequence</classname> is a
    simple string description of the <classname>Sequence</classname>:
    normally the name or accession number of the
    <classname>Sequence</classname> in the database from which it is
    retrieved. The getURN method, on the other hand, should return a
    more structured identifier for the sequence, represented as a
    Uniform Resource Identifier (URI) e.g.:</para>

    <itemizedlist>
      <listitem>
        <para><literal>urn:sequence/embl:AL121903</literal></para>
      </listitem>
      <listitem>
        <para><literal>file:///home/thomas/genome.fasta|rpoN</literal></para>
      </listitem>
      <listitem>
        <para><literal>http://adzel.casseiopeia.org/seqs/myseqs.fasta|seq0001</literal></para>
      </listitem>
      <listitem>
        <para><literal>acedb://humace.sanger.ac.uk/DNA/AL121903</literal></para>
      </listitem>
    </itemizedlist>

    <para>URNs are a special class of URIs which represent global
    names for 'well known' resources. Note that, despite the method
    name, it may not be appropriate to give an actual URN for
    sequences. However, for sequences from databases such as EMBL,
    where many sites have local installations, use of URNs is
    encouraged.</para>

    <para>The exact use of the name and URN properties is currently
    dependent to some extent on how the sequence was loaded. As
    BioJava enters more common use, more formal definitions of these
    properties will emerge.</para>
  </sect1>

  <sect1 id="bd-ch03-annotation">
    <title>Other annotations</title>

    <para>In addition to the two 'identifier' properties of the
    <classname>Sequence</classname>, it may have other annotation data
    associated with it. BioJava contains an
    <classname>Annotation</classname> interface, which represents a
    set of key-value pairs, a little like a Java
    <classname>Map</classname> (indeed,
    <classname>Annotation</classname> has an asMap method).</para>

<programlisting>
Sequence seq = getSequence();
Annotation seqAn = seq.getAnnotation();
for (Iterator i = seqAn.keys().iterator(); i.hasNext(); ) {
    Object key = i.next();
    Object value = seqAn.getProperty(key);
    System.out.println(key.toString() + ": " + value.toString());
}
</programlisting>

    <para><classname>Annotation</classname> objects aren't just used
    in <classname>Sequence</classname>s -- many other BioJava objects,
    including <classname>Feature</classname>s, can also have
    annotations associated with them.</para>

    <para>Currently, there are no specific conventions for the kind of
    data which might be found in an
    <classname>Annotation</classname>. In general, the keys should be
    strings (although there is no requirement that this be the
    case). But the values may be any Java object. More guidelines for
    the contents of <classname>Annotation</classname> objects may be
    introduced as BioJava develops.</para>
  </sect1>

  <sect1 id="bd-ch03-features">
    <title><classname>Feature</classname>s and
    <classname>FeatureHolder</classname>s</title>

    <para>A <classname>Feature</classname> represents a region of a
    sequence with some defined properties attached. Typically,
    features might represent structures such as genes and repeat
    elements on chromosomes, or alpha helices in proteins. As a Java
    interface, <classname>Feature</classname> has the following basic
    properties:</para>

    <itemizedlist>
      <listitem>
        <para>A location within the sequence, represented by a
        <classname>Location</classname> object. This has a defined
        start and end (equal in the case of point locations), and may
        or may not be contiguous.</para>
      </listitem>
      <listitem>
        <para>A type (for instance, "gene" or "helix").</para>
        </listitem>
      <listitem>
        <para>A source (often the name of the program which discovered
        the feature.</para>
      </listitem>
      <listitem>
        <para>An <classname>Annotation</classname> object, which can
        contain any other data. In addition, all
        <classname>Feature</classname>s have a place in a "tree" of
        <classname>Feature</classname>s, attached to a
        <classname>Sequence</classname>. <classname>Feature</classname>s
        cannot be created independently of a
        <classname>Sequence</classname>.</para>
      </listitem>
    </itemizedlist>

    <para>If a large class of features exists which have important
    properties over and above those represented in the
    <classname>Feature</classname> interface, a sub-interface of
    <classname>Feature</classname> may be defined. Currently, there is
    only one such sub-interface in the BioJava core:
    <classname>StrandedFeature</classname>. This is used for features
    in duplex DNA which have a defined directionality. For instance,
    genes would normally be represented with
    <classname>StrandedFeatures</classname>, while some kinds of
    regulatory region might be plain
    <classname>Feature</classname>s.</para>

    <para>Sets of <classname>Feature</classname>s are stored in
    objects implementing the <classname>FeatureHolder</classname>
    interface. Sequence is a sub-interface of
    <classname>FeatureHolder</classname>. <classname>Feature</classname>
    itself also extends FeatureHolder, giving the possibility of
    representing 'nested' features. For instance, a
    <classname>Feature</classname> representing a large genetic
    regulatory region might contain sub-features annotating individual
    transcription factor binding sites. The recursive method below
    will print a simple text representation of a tree of
    features:</para>

<programlisting>
public void printFeatures(FeatureHolder fh, 
                          PrintWriter pw,
                          String prefix)
{
    for (Iterator i = fh.features(); i.hasNext(); ) {
        Feature f = (Feature) i.next();
        pw.print(prefix);
        pw.print(f.getType());
        pw.print(" at ");
        pw.print(f.getLocation().toString());
        pw.println();
        printFeatures(f, pw, prefix + "    ");
    }
}
</programlisting>

    <para>all <classname>Feature</classname> implementations include
    two methods which indicate how it fits into a feature
    tree. <methodname>getParent</methodname> returns the
    <classname>FeatureHolder</classname>
    (<classname>Sequence</classname> or
    <classname>Feature</classname>) which is the feature's immediate
    parent, while <methodname>getSequence</methodname> returns the
    <classname>Sequence</classname> object which is the root of the
    tree. <classname>Feature</classname> objects are always associated
    with a specific sequence, and always have exactly one parent
    <classname>FeatureHolder</classname>.</para>
  </sect1>

  <sect1 id="bd-ch03-newfeatures">
    <title>Creating new features</title>

    <para>It is expected that there will never be any publicly visible
    implementations of <classname>Feature</classname> or its
    sub-interfaces. Instead, features should be produced using the
    createFeature method of a
    <classname>FeatureHolder</classname>. This ensures that there are
    no 'orphan' features, not properly attached to a parent
    <classname>Sequence</classname>. It also gives
    <classname>Sequence</classname> implemetors the chance to control
    the attachment of features to their sequence class. Some sequences
    may only accept certain kinds of feature. Other implementations,
    especially those intimately coupled with database storage
    mechanisms, may wish to use their own special implementations of
    the <classname>Feature</classname> interface.</para>

    <para>The createFeature method has the following signature:</para>
<programlisting>
public Feature createFeature(Feature.Template template);
</programlisting>

    <para>There is no requirement that a particular
    <classname>FeatureHolder</classname> should include a working
    implementation of this method. If it is not possible to create a
    new child feature,
    <classname>UnsupportedOperationException</classname> will be
    thrown. In particular, this method is only implemented by
    <classname>Sequence</classname> and <classname>Feature</classname>
    objects. When <classname>FeatureHolder</classname> instances are
    used to return arbitrary 'bags' of features, they will never
    support this method.</para>

    <para><classname>Feature.Template</classname> is a concrete nested
    class of the <classname>Feature</classname> interface. It just
    contains public fields corresponding to each property of
    <classname>Feature</classname>. A feature could be attached to a
    <classname>Sequence</classname> as follows:</para>

<programlisting>
Feature.Template template = new Feature.Template();
template.type = "TestFeature";
template.source = "Test";
template.location = new RangeLocation(100, 200);
template.annotation = Annotation.EMPTY_ANNOTATION;
mySequence.createFeature(template);
</programlisting>

    <para>Every sub-interface of <classname>Feature</classname> should
    have a nested class, also named <classname>Template</classname>,
    which extends <classname>Feature.Template</classname> and adds any
    extra fields needed to construct that specialized kind of
    feature.</para>
  </sect1>
</chapter>
  
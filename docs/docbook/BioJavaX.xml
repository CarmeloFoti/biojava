<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">
<book>
  <title>BioJavaX</title>

  <bookinfo>
    <date>28th October 2005</date>

    <author>
      <firstname>Richard</firstname>

      <surname>Holland</surname>
    </author>

    <author>
      <firstname>Mark</firstname>

      <surname>Schreiber</surname>
    </author>

    <edition>0.1</edition>
  </bookinfo>

  <chapter>
    <title>BioJavaX is not BioJava 2 is not BioJavaX.</title>

    <para>BioJavaX is an extension to the existing BioJava project. Anything
    written with BioJava will work with BioJavaX, and vice versa.</para>

    <para><code>org.biojavax</code> is to <code>org.biojava</code> as
    <code>javax</code> is to <code>java</code>.</para>

    <para>The BioJava2 project is a completely new project which intends to
    rewrite everything in BioJava from scratch, based around a new set of
    object designs and concepts. It is entirely incompatible with the existing
    BioJava project.</para>

    <para>Therefore BioJavaX is <emphasis>not</emphasis> BioJava 2, and has
    nothing to do with it. Please don't get them confused!</para>
  </chapter>

  <chapter>
    <title>What didn't change?</title>

    <section>
      <title>Existing interfaces.</title>

      <para>Backwards-compatibility is always an issue when a major new
      version of a piece of software is released.</para>

      <para>BioJavaX addresses this by keeping all the new classes and
      interfaces tucked away inside their own special package,
      <code>org.biojavax</code>. None of the existing interfaces were modified
      in any way, so any code which depends on them will not see any
      difference.</para>

      <para>Apart from ongoing bugfixes, the way in which the existing classes
      work also has not changed.</para>

      <para>The new interfaces introduced in BioJavaX extend those present in
      the existing BioJava packages. This allows new BioJavaX-derived objects
      to be passed to legacy code and still be understood.</para>
    </section>

    <section>
      <title>Change listeners.</title>

      <para>BioJava's change listener model is intact and unchanged. The new
      BioJavaX classes define a set of extra change types which they fire in
      addition to the ones generated by existing BioJava classes.</para>

      <para>This means that existing change listeners can be attached to
      BioJavaX-derived objects and still receive all the information they
      would normally receive.</para>
    </section>

    <section>
      <title>Event-based file parsing.</title>

      <para>BioJavaX still uses event-based file parsing to read and write
      files, in exactly the same way as the old BioJava classes did.</para>

      <para>However, you cannot use existing event listeners with the new
      BioJavaX file parsers. You must alter the listeners to extend the new
      <code>org.biojavax.bio.seq.io.RichSeqIOListener</code> interface
      instead.</para>
    </section>
  </chapter>

  <chapter>
    <title>What did change?</title>

    <section>
      <title>System requirements.</title>

      <para>Java 1.4 is required for all BioJavaX packages.</para>
    </section>

    <section>
      <title>Rich interfaces.</title>

      <para>BioJavaX defines a new set of interfaces for working with sequence
      objects. These interfaces are closely modelled on the BioSQL 1.0
      schema.</para>

      <para>The new interfaces extend existing interfaces wherever possible,
      in order to allow backwards-compatibility with legacy code. These
      interfaces are known as rich interfaces, as they could be said to be
      'enriched' versions of the interfaces that they extend.</para>

      <para>Instances of implementing classes are known as rich objects, which
      legacy instances known as plain ones.</para>

      <para>Here is a list of the new rich interfaces:</para>

      <itemizedlist>
        <listitem>
          <para><code>ComparableOntology</code> (extends
          <code>Ontology</code>)</para>
        </listitem>

        <listitem>
          <para><code>ComparableTerm</code> (extends <code>Term</code>)</para>
        </listitem>

        <listitem>
          <para><code>ComparableTriple</code> (extends
          <code>Triple</code>)</para>
        </listitem>

        <listitem>
          <para><code>RichSequenceIterator</code> (extends
          <code>SequenceIterator</code>)</para>
        </listitem>

        <listitem>
          <para><code>RichSequence</code> (extends
          <code>Sequence</code>)</para>
        </listitem>

        <listitem>
          <para><code>RichLocation</code> (extends
          <code>Location</code>)</para>
        </listitem>

        <listitem>
          <para><code>RichFeature</code> (extends
          <code>StrandedFeature</code>)</para>
        </listitem>

        <listitem>
          <para><code>RichFeatureHolder</code> (extends
          <code>FeatureHolder</code>)</para>
        </listitem>

        <listitem>
          <para><code>RichAnnotatable</code> (extends
          <code>Annotatable</code>)</para>
        </listitem>

        <listitem>
          <para><code>RichAnnotation</code> (extends
          <code>Annotation</code>)</para>
        </listitem>
      </itemizedlist>

      <para>Wherever possible in BioJavaX, conversions are attempted if a
      method expecting a rich object receives a plain one. You can perform
      these conversions yourself by using the <code>Tools</code> sub-class of
      the appropriate rich interface, for example to convert an old
      <code>Sequence</code> object into a new <code>RichSequence</code>
      object, you can do this:</para>

      <programlisting>Sequence s = ...; // get an old Sequence object from somewhere
RichSequence rs = RichSequence.Tools.enrich(s);</programlisting>

      <para>The conversion process does its best, but it is not perfect. Much
      of the way information is stored in the new BioJavaX object model is
      fundamentally incompatible with the old object model. So its always best
      to deal with <code>RichSequence</code> objects from the word go and try
      to avoid instantiating older <code>Sequence</code> objects as far as
      possible.</para>

      <para>Other new interfaces define new concepts, or replace old
      interfaces entirely due to a fundamental clash in the way they see the
      world. Here is a list:</para>

      <itemizedlist>
        <listitem>
          <para><code>NCBITaxon</code></para>
        </listitem>

        <listitem>
          <para><code>BioEntry</code></para>
        </listitem>

        <listitem>
          <para><code>RichObjectBuilder</code></para>
        </listitem>

        <listitem>
          <para><code>Comment</code></para>
        </listitem>

        <listitem>
          <para><code>CrossRef</code></para>
        </listitem>

        <listitem>
          <para><code>CrossReferenceResolver</code></para>
        </listitem>

        <listitem>
          <para><code>DocRef</code></para>
        </listitem>

        <listitem>
          <para><code>DocRefAuthor</code></para>
        </listitem>

        <listitem>
          <para><code>Namespace</code></para>
        </listitem>

        <listitem>
          <para><code>Note</code></para>
        </listitem>

        <listitem>
          <para><code>RankedCrossRef</code></para>
        </listitem>

        <listitem>
          <para><code>RankedCrossRefable</code></para>
        </listitem>

        <listitem>
          <para><code>RankedDocRef</code></para>
        </listitem>

        <listitem>
          <para><code>BioEntryRelationship</code></para>
        </listitem>

        <listitem>
          <para><code>Position</code></para>
        </listitem>

        <listitem>
          <para><code>PositionResolver</code></para>
        </listitem>

        <listitem>
          <para><code>RichFeatureRelationship</code></para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>BioSQL persistence.</title>

      <para>BioJavaX introduces a whole new way of working with BioSQL
      databases.</para>

      <para>Instead of attempting to re-invent the wheel with yet another new
      object-relational mapping system, BioJavaX uses the services of
      Hibernate to do all the dirty work for it. In fact, there is not a
      single SQL statement anywhere in the BioJavaX code.</para>

      <para>The use of Hibernate allows users to have as much or as little
      control as they like over transactions and query optimisation. The
      Hibernate query language, HQL, is simple to learn and easy to
      use.</para>

      <para>You can find out more about the Hibernate project at their
      website: <ulink
      url="http://www.hibernate.org/">http://www.hibernate.org/</ulink></para>
    </section>

    <section>
      <title>Better file parsers.</title>

      <para>The old BioJava file parsers worked in that they loaded all
      information into memory, but they didn't do much at attempting to
      understand the contents of the files, and they often failed miserably
      when trying to convert between formats.</para>

      <para>The new parsers supplied with BioJavaX put a lot of effort into
      trying to fit data from the myriad of file formats out there into a form
      representable by BioSQL, and hence by the new BioJavaX object model. Of
      course this isn't always possible, but it does a much better job than
      the old ones.</para>

      <para>By parsing data into a fixed object model instead of storing
      everything as annotations (as was the case, for instance, with the old
      SwissProt parsers), conversion between file formats becomes much
      easier.</para>

      <para>The new file parsers also allow you to skip uninteresting parts of
      the file altogether, greatly speeding up simple tasks such as counting
      the number of sequences in a file.</para>
    </section>

    <section>
      <title>NCBI Taxonomy loader.</title>

      <para>A parser is provided for loading the NCBI Taxonomy database into a
      set of BioJavaX <code>NCBITaxon</code> objects. This parser reads the
      <filename>node.dmp</filename> and <filename>names.dmp</filename> files
      supplied by NCBI and constructs the appropriate hierarchy of objects. If
      you are using BioSQL, it can persist this hierarchy to the database as
      it goes.</para>
    </section>

    <section>
      <title>Namespaces.</title>

      <para>All sequences in BioJavaX must belong to a namespace.</para>
    </section>

    <section>
      <title>Singletons.</title>

      <para>BioJavaX tries to use singletons as far as possible. This
      is:</para>

      <itemizedlist>
        <listitem>
          <para>to reduce memory usage.</para>
        </listitem>

        <listitem>
          <para>to prevent problems with duplicate keys when persisting to
          BioSQL.</para>
        </listitem>
      </itemizedlist>

      <para>The singletons are kept in a LRU cache managed by a
      <code>RichObjectFactory</code>. See the chapter on this subject later in
      this book.</para>
    </section>

    <section>
      <title>Genetic algorithms.</title>

      <para>BioJavaX introduces a new package for working with genetic
      algorithms.</para>
    </section>
  </chapter>

  <chapter>
    <title>Future plans.</title>

    <section>
      <title>BioPerl and BioPerl-DB compatibility.</title>

      <para>We tried our best to store sequence data into BioSQL in the same
      way as BioPerl-DB does. We also tried to parse files in such a way that
      data from files would end up in the same place in BioSQL as if it had
      been parsed using the BioPerl file parsers then persisted using
      BioPerl-DB.</para>

      <para>However, we may not have been entirely successful, particularly
      with regard to the naming conventions of annotations and feature
      qualifiers, and the use of the document and publication cross-reference
      tables. Likewise, our definition of fuzzy locations may differ.</para>

      <para>So, we intend in the future to try and consolidate our efforts
      with those of the BioPerl and BioPerl-DB projects, along with any of the
      other Bio* projects who provide BioSQL persistence functionality, so
      that we can all read and write data to and from BioSQL in the same
      way.</para>

      <para>The goal is to be able to read a file with any of the Bio*
      projects, persist it to the database, then read it back from the
      database using any of the other Bio* projects and write it out to file.
      The input and output files should be logically identical (give or take
      some minor layout or formatting issues).</para>

      <para>Help is needed!</para>
    </section>

    <section>
      <title>Efficient parsing.</title>

      <para>The event-based parser model works great, but our implementations
      of actual file parsing code may leave a lot to be desired in terms of
      efficient use of memory or minimising the number of uses of markers in
      the input stream.</para>

      <para>If you are an IO, parsing, or code optimisation guru, you would be
      most welcome to come have a look and speed things up a bit.</para>
    </section>

    <section>
      <title>More file formats supported.</title>

      <para>We've provided parsers (and writers) for all the major formats we
      thought would be necessary. But there are only two of us, and it takes a
      while to trawl through the documentation for each format and try to
      shoehorn it all into the BioSQL model, even before the actual coding
      begins.</para>

      <para>If there's a format you like and use daily and you think would be
      of use to others, but you can't find it in BioJavaX, then please do
      write a parser for it and contribute it to the project.</para>
    </section>

    <section>
      <title>Persistence to non-BioSQL databases.</title>

      <para>Basically, right now, you can't. We have only provided Hibernate
      mappings for BioSQL.</para>

      <para>There is no reason though why you can't write a new set of
      Hibernate XML mapping files that map the BioJavaX objects into tables in
      some other database format. Because of the way Hibernate works, you
      wouldn't have to change any of the BioJavaX code at all, only the
      mapping files that tell Hibernate how to translate between objects and
      tables.</para>

      <para>If you do, and you think someone else could benefit from your
      work, please consider contributing them to the BioJava project for
      everyone to enjoy.</para>
    </section>

    <section>
      <title>Java 1.5 and Generics.</title>

      <para>Much discussion has occurred recently about upgrading BioJava to
      use features only available since version 1.5 of Java (also known as
      Java 5). Mostly we are considering the use of generics.</para>

      <para>A lot of this started after some Java 1.5 features accidentally
      slipped into the biojava-live CVS branch one day and suddenly nobody
      using older JVMs could compile it any more. These were quickly removed,
      and it was agreed to wait a while before a decision was made about the
      ultimate use of such features.</para>

      <para>Java 1.5 offers a lot of features that would be very useful in
      BioJava, and has the potential to greatly reduce the size of the
      project's codebase. However, 1.5 compilers and runtime environments are
      not available for some platforms yet, and in other situations companies
      are reluctant to upgrade when they have already settled on 1.4 as their
      tested and accepted Java environment.</para>

      <para>So, we won't do it yet, but we would definitely like to change in
      future.</para>
    </section>
  </chapter>

  <chapter>
    <title>Singletons and the <code>RichObjectFactory</code>.</title>

    <section>
      <title>Using <code>RichObjectFactory</code>.</title>

      <para>BioJavaX revolves around the use of singleton instances. This is
      important to keep memory usage down, and becomes even more important
      when working with BioSQL databases via Hibernate to prevent duplicate
      records in tables. Singletons are generated in a singleton
      factory.</para>

      <para><code>RichObjectFactory</code> is a caching singleton factory. If
      you request lots of instances of the same class, the oldest ones are
      forgotten about and you will get a new instance next time you ask for
      it. This is to prevent memory blowouts. The default size of this LRU
      cache is 20 instances of each class.</para>

      <para>Singletons are only important when dealing with certain
      classes:</para>

      <itemizedlist>
        <listitem>
          <para><code>SimpleNamespace</code></para>
        </listitem>

        <listitem>
          <para><code>SimpleComparableOntology</code></para>
        </listitem>

        <listitem>
          <para><code>SimpleNCBITaxon</code></para>
        </listitem>

        <listitem>
          <para><code>SimpleCrossRef</code></para>
        </listitem>

        <listitem>
          <para><code>SimpleDocRef</code></para>
        </listitem>
      </itemizedlist>

      <para>In all other cases, you don't need to worry about singletons. In
      fact, the singleton factory may complain if you try to ask it to make a
      singleton of any class not listed above.</para>

      <para>To generate a new instance of any of the above, you must use the
      <code>RichObjectFactory</code>. This tool checks an LRU cache to see if
      you have requested an identical instance recently. If you have, it
      returns that instance (a singleton). If you haven't, then it creates the
      instance, adds it to the LRU cache, then returns it.</para>

      <para>The parameters you supply to the <code>RichObjectFactory</code>
      are a class name, and an array of parameters which you would normally
      have passed directly to that class' constructor. Here is a list of the
      parameters required, and an example, for each of the classes accepted by
      the current factory:</para>

      <table>
        <title><code>RichObjectFactory</code> singleton examples.</title>

        <tgroup cols="3">
          <tbody>
            <row>
              <entry><code>SimpleNamespace</code></entry>

              <entry>[name (<code>String</code>)]</entry>

              <entry><programlisting>Namespace ns = (Namespace)RichObjectFactory.getObject(
                             Namespace.class, 
                             new Object[]{"myNamespace"}
                          );</programlisting></entry>
            </row>

            <row>
              <entry><code>SimpleComparableOntology</code></entry>

              <entry>[name (<code>String</code>)]</entry>

              <entry><programlisting>ComparableOntology ont = (ComparableOntology)RichObjectFactory.getObject(
                                                ComparableOntology.class, 
                                                new Object[]{"myOntology"}
                                             );</programlisting></entry>
            </row>

            <row>
              <entry><code>SimpleNCBITaxon</code></entry>

              <entry>[taxID (<code>Integer</code>)]</entry>

              <entry><programlisting>Integer taxID = new Integer(12345);
NCBITaxon tax = (NCBITaxon)RichObjectFactory.getObject(
                              SimpleNCBITaxon.class, 
                              new Object[]{taxID}
                           );</programlisting></entry>
            </row>

            <row>
              <entry><code>SimpleCrossRef</code></entry>

              <entry>[databaseName (<code>String</code>), accession
              (<code>String</code>), version (<code>Integer</code>)]</entry>

              <entry><programlisting>Integer version = new Integer(0);
CrossRef cr = (CrossRef)RichObjectFactory.getObject(
                           SimpleCrossRef.class, 
                           new Object[]{"PUBMED","56789",version}
                        );</programlisting></entry>
            </row>

            <row>
              <entry><code>SimpleDocRef</code></entry>

              <entry>[authors (<code>List</code> of
              <code>DocRefAuthor</code>), location
              (<code>String</code>)]</entry>

              <entry><programlisting>DocRefAuthor author = new SimpleDocRefAuthor("Bloggs,J.");
List authors = new ArrayList();
authors.add(author);
DocRef dr = (DocRef)RichObjectFactory.getObject(
                       SimpleDocRef.class, 
                       new Object[]{authors,"Journal of Voodoo Virology, 2005, 23:55-57"}
                    );</programlisting></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>Where the singletons come from.</title>

      <para>The actual instances of the classes requested are generated using
      a <code>RichObjectBuilder</code>. The default
      <code>RichObjectBuilder</code>, <code>SimpleRichObjectBuilder</code>,
      uses introspection to call the constructors on the classes and create
      new instances. You do not need to do anything to set this up.</para>

      <para>If you do decide to write your own <code>RichObjectBuilder</code>
      for whatever reason, you can set it to be used by
      <code>RichObjectFactory</code> like this:</para>

      <programlisting>RichObjectBuilder builder = ...; // create your own one here
RichObjectFactory.setRichObjectBuilder(builder); // make the factory use it from now on</programlisting>

      <para>If you change the default <code>RichObjectBuilder</code> to a
      different one, you <emphasis>must</emphasis> do so at the very beginning
      of your program before any call to the <code>RichObjectFactory</code>
      has been made. This is because when the builder is changed, existing
      singletons or default instances are not removed. If you do not follow
      this guideline, you will end up with a mix of objects in the cache
      created by two different builders, which could lead to interesting
      situations.</para>
    </section>

    <section>
      <title>Hibernate singletons.</title>

      <para>When working with Hibernate, you <emphasis>must</emphasis>
      instantiate the <code>HibernateRichObjectBuilder</code>. When using
      this, instances are looked up in the underlying BioSQL database first to
      see if they exist. If they do, they are loaded and returned. If not,
      they are created, then returned.</para>

      <para>The instances returned by <code>RichObjectFactory</code> when
      using the <code>HibernateRichObjectBuilder</code> are guaranteed true
      singletons and will never be duplicated even if you fill up the LRU
      cache several times between requests.</para>

      <para>See the section on BioSQL and Hibernate later in this document for
      more details.</para>
    </section>

    <section>
      <title>Managing the LRU cache.</title>

      <para>By default, the LRU cache keeps the 20 most recently requested
      instances of any given class in memory. If more than 20 objects are
      requested, the oldest ones are removed from the cache before the new
      ones are added. This keeps memory usage at a minimum.</para>

      <para>If you are experiencing problems with duplicate instances when you
      expected singletons., or believe that a larger or smaller cache may help
      the performance of your application, then you can change the size of the
      LRU cache. There are two ways of doing this.</para>

      <para>Changes to the LRU cache size are not instantaneous. The size of
      the cache only changes physically next time an instance is requested
      from it. Even then, only the cache of instances of the class requested
      will actually change.</para>

      <section>
        <title>Global LRU cache size.</title>

        <para>Changing the global LRU cache size will change the cache size
        for all classes. It applies the new cache size to every single class.
        Next time any of those classes are accessed via the RichObjectFactory,
        the LRU cache for that class will adjust to the new size.</para>

        <programlisting>RichObjectFactory.setLRUCacheSize(50); // increases the global LRU cache size to 50 instances per class</programlisting>
      </section>

      <section>
        <title>Class-specific LRU cache size.</title>

        <para>Changing the LRU cache size for a specific class will only
        affect that class. Your class-specific settings will be lost if you
        later change the global LRU cache size.</para>

        <programlisting>RichObjectFactory.setLRUCacheSize(SimpleNamespace.class, 50); // increases the LRU cache for SimpleNamespace instances to 50</programlisting>
      </section>
    </section>

    <section>
      <title>Convenience methods.</title>

      <para>A number of convenience methods are provided by the
      RichObjectFactory to allow easy access to some useful default
      singletons:</para>

      <table>
        <title><code>RichObjectFactory</code> convenience methods.</title>

        <tgroup cols="2">
          <tbody>
            <row>
              <entry><code>void setDefaultNamespaceName(String
              name);</code></entry>

              <entry>Sets the name of the default namespace. This namespace is
              used when loading files which have no namespace information of
              their own, and when no namespace has been passed to the file
              loading routines. It can also be used when creating temporary
              <code>RichSequence</code> or <code>BioEntry</code> objects, as
              the namespace parameter is compulsory on these objects.</entry>
            </row>

            <row>
              <entry><code>Namespace getDefaultNamespace();</code></entry>

              <entry>Returns the default namespace singleton instance
              (delegates to <code>getObject()</code>).</entry>
            </row>

            <row>
              <entry><code>void setDefaultOntologyName(String
              name);</code></entry>

              <entry>Sets the name of the default ontology. When parsing
              files, new terms are often created. If the file format does not
              have an ontology of its own, then it will use the default
              ontology to store these terms. Terms commonly used throughout
              BioJavaX, including those common to all file formats, are also
              stored in the default ontology.</entry>
            </row>

            <row>
              <entry><code>ComparableOntology
              getDefaultOntology();</code></entry>

              <entry>Returns the default ontology singleton instance
              (delegates to <code>getObject()</code>).</entry>
            </row>

            <row>
              <entry><code>void setDefaultPositionResolver(PositionResolver
              pr);</code></entry>

              <entry>When converting fuzzy locations into actual physical
              locations, a <code>PositionResolver</code> instance is used. The
              default one is <code>AveragePositionResolver</code>, which
              averages out the range of fuzziness to provide a value somewhere
              in the middle. You can override this setting using this
              function. All locations that are resolved without explicility
              specifying a <code>PositionResolver</code> to use will then use
              this resolver to do the work.</entry>
            </row>

            <row>
              <entry><code>PositionResolver
              getDefaultPositionResolver();</code></entry>

              <entry>Returns the default position resolver.</entry>
            </row>

            <row>
              <entry><code>void
              setDefaultCrossReferenceResolver(CrossReferenceResolver
              cr);</code></entry>

              <entry><code>CrossRef</code> instances are links to other
              databases. When a <code>CrossRef</code> is used in a
              <code>RichLocation</code> instance, it means that to obtain the
              symbols (sequence) for that location, it must first retrieve the
              remote sequence object. The <code>CrossReferenceResolver</code>
              object specified using this method is used to carry this out.
              The only implementation of this interface at present is
              <code>SimpleCrossReferenceResolver</code>, which is the one used
              by default.</entry>
            </row>

            <row>
              <entry><code>CrossReferenceResolver
              getDefaultCrossReferenceResolver();</code></entry>

              <entry>Returns the default cross reference resolver.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>Default settings.</title>

      <para>The default namespace name is <code>lcl</code>.</para>

      <para>The default ontology name is <code>biojavax</code>.</para>

      <para>The default LRU cache size is 20.</para>

      <para>The default position resolver is
      <code>AveragePositionResolver</code>.</para>

      <para>The default cross reference resolver is
      <code>SimpleCrossReferenceResolver</code>.</para>
    </section>
  </chapter>

  <chapter>
    <title>Working with sequences.</title>

    <section>
      <title>Creating sequences.</title>

      <para>BioJavaX has a two-tier definition of sequence data.</para>

      <para><code>BioEntry</code> objects correspond to the
      <code>bioentry</code> table in BioSQL. They do not have any sequence
      information, and neither do they have any features. They can, however,
      be annotated, commented, and put into relationships with each other.
      They can also have cross-references to publications and other databases
      associated with them.</para>

      <para><code>RichSequence</code> objects extend <code>BioEntry</code>
      objects by adding in sequence data and a feature table.</para>

      <para>So, when to use them?</para>

      <itemizedlist>
        <listitem>
          <para><code>BioEntry</code> objects are most useful when performing
          simple operations such as counting sequences, checking taxonomy
          data, looking up accessions, or finding out things like which
          objects refer to a particular PUBMED entry.</para>
        </listitem>

        <listitem>
          <para><code>RichSequence</code> objects are useful only when you
          need access to the sequence data itself, or to the sequence feature
          table.</para>
        </listitem>

        <listitem>
          <para><code>RichSequence</code> objects must be used whenever you
          wish to pass objects to legacy code that is expecting
          <code>Sequence</code> objects, as only <code>RichSequence</code>
          objects implement the <code>Sequence</code> interface.
          <code>BioEntry</code> objects do not.</para>
        </listitem>
      </itemizedlist>

      <para>Throughout the rest of this document, both <code>BioEntry</code>
      and <code>RichSequence</code> objects will be referred to
      interchangeably as sequence objects.</para>

      <para>To create a <code>BioEntry</code> object, you need to have at
      least the following information:</para>

      <itemizedlist>
        <listitem>
          <para>a <code>Namespace</code> instance to associate the sequence
          with (use <code>RichObjectFactory.getDefaultNamespace()</code> for
          an easy way out)</para>
        </listitem>

        <listitem>
          <para>a name for the sequence</para>
        </listitem>

        <listitem>
          <para>an accession for the sequence</para>
        </listitem>

        <listitem>
          <para>a version for the sequence (use 0 if you don't want to bother
          with versions)</para>
        </listitem>
      </itemizedlist>

      <para>To create a <code>RichSequence</code> object, you need to have all
      the above plus:</para>

      <itemizedlist>
        <listitem>
          <para>a <code>SymbolList</code> containing the sequence data</para>
        </listitem>

        <listitem>
          <para>a version for the sequence data (this is separate from the
          version of the sequence object)</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Multiple accessions.</title>

      <para>If you wish to assign multiple accessions to a sequence, you must
      do so using the special term provided, like this:</para>

      <programlisting>ComparableTerm accTerm = RichSequence.Terms.getAdditionalAccessionTerm();
Note accession1 = new SimpleNote(accTerm,"A12345",1); // this note has an arbitrary rank of 1
Note accession2 = new SimpleNote(accTerm,"Z56789",2); // this note has an arbitrary rank of 2
...
RichSequence rs = ...; // get a rich sequence from somewhere
rs.getNoteSet().add(accession1); // annotate the rich sequence with the first additional accession
rs.getNoteSet().add(accession2); // annotate the rich sequence with the second additional accession
...
// you can annotate bioentry objects in exactly the same way
BioEntry be = ...; // get a bioentry from somewhere
be.getNoteSet().add(accession1); 
be.getNoteSet().add(accession2); </programlisting>

      <para>See later in this document for more information on how to annotate
      and comment on sequences.</para>
    </section>

    <section>
      <title>Circular sequences.</title>

      <para>BioJavaX can flag sequences as being circular, using the
      <code>setCircular()</code> and <code>getCircular()</code> methods on
      <code>RichSequence</code> instances. However, as this information is not
      part of BioSQL, it will be lost when the sequence is persisted to a
      BioSQL database. Use with care.</para>

      <para>Note that only circular sequences can have features with circular
      locations associated with them.</para>
    </section>
  </chapter>

  <chapter>
    <title>Relationships between sequences.</title>

    <section>
      <title>Relating two sequences.</title>

      <para>Two sequences can be related to each other by using a
      <code>BioEntryRelationship</code> object to construct the link.</para>

      <para>Relationships are optionally ranked. If you don't want to rank the
      relationship, use null in the constructor.</para>

      <para>The following code snippet defines a new term "contains" in the
      default ontology, then creates a relationship that states that sequence
      A (the parent) contains sequence B (the child):</para>

      <programlisting>ComparableTerm contains = RichObjectFactory.getDefaultOntology().getOrCreateTerm("contains");
...
RichSequence parent = ...; // get sequence A from somewhere 
RichSequence child = ...; // get sequence B from somewhere
BioEntryRelationship relationship = new SimpleBioEntryRelationship(parent,child,contains,null);
parent.addRelationship(relationship); // add the relationship to the parent
...
parent.removeRelationship(relationship); // you can always take it away again later</programlisting>
    </section>

    <section>
      <title>Querying the relationship.</title>

      <para>Sequences are only aware of relationships in which they are the
      parent sequence. A child sequence cannot find out which parent sequences
      it is related to.</para>

      <para>The following code snippet prints out all the relationships a
      sequence has with child sequences:</para>

      <programlisting>RichSequence rs = ...; // get a rich sequence from somewhere
for (Iterator i = rs.getRelationships().iterator(); i.hasNext(); ) {
     BioEntryRelationship br = (BioEntryRelationship)i.next();
     BioEntry parent = br.getObject(); // parent == rs
     BioEntry child = br.getSubject(); 
     ComparableTerm relationship = br.getTerm();
     // print out the relationship (eg. "A contains B");
     System.out.println(parent.getName()+" "+relationship.getName()+" "+child.getName());
}</programlisting>
    </section>
  </chapter>

  <chapter>
    <title>Reading and writing files.</title>

    <section>
      <title>Tools for reading/writing files.</title>

      <para>BioJavaX provides a replacement set of tools for working with
      files. This is necessary because the new file parsers must work with the
      new <code>RichSeqIOListener</code> in order to preserve all the
      information from the file correctly. </para>

      <para>The tools can all be found in <code>RichSequence.IOTools</code>, a
      subclass of the <code>RichSequence</code> interface. For each file
      format there are a number of utility methods in this class for reading a
      variety of sequence types, and writing them out again. See later
      sections of this chapter for details on individual formats.</para>

      <para>For those who like to do things the hard way, reading and writing
      by directly using the <code>RichStreamReader</code> and
      <code>RichStreamWriter</code> interfaces is described below.</para>

      <section>
        <title>Reading using <code>RichStreamReader</code>.</title>

        <para>File reading is based around the concept of a
        <code>RichStreamReader</code>. This object returns a
        <code>RichSequenceIterator</code> which iterates over every sequence
        in the file on demand.</para>

        <para>To construct a <code>RichStreamReader</code>, you will need five
        things.</para>

        <orderedlist>
          <listitem>
            <para>a <code>BufferedReader</code> instance which is connected to
            the file you wish to parse.</para>
          </listitem>

          <listitem>
            <para>a <code>RichSequenceFormat</code> instance which understands
            the format of the file (eg. <code>FastaFormat</code>,
            <code>GenbankFormat</code>, etc.)</para>
          </listitem>

          <listitem>
            <para>a <code>SymbolTokenization</code> which understands how to
            translate the sequence data in the file into a BioJava
            <code>SymbolList</code>.</para>
          </listitem>

          <listitem>
            <para>a <code>RichSequenceBuilderFactory</code> instance which
            generates instances of <code>RichSequenceBuilder</code>.</para>
          </listitem>

          <listitem>
            <para>a <code>Namespace</code> instance to associate the sequences
            with.</para>
          </listitem>
        </orderedlist>

        <para>The <code>RichSequenceBuilderFactory</code> is best set to one
        of the predefined constants in the
        <code>RichSequenceBuilderFactory</code> interface. These constants are
        defined as:</para>

        <table>
          <title><code>RichSequenceBuilderFactory</code> predefined
          constants.</title>

          <tgroup cols="2">
            <tbody>
              <row>
                <entry><code>RichSequenceBuilderFactor.FACTORY</code></entry>

                <entry>Does not attempt any compression on sequence
                data.</entry>
              </row>

              <row>
                <entry><code>RichSequenceBuilderFactor.PACKED</code></entry>

                <entry>Will compress all sequence data using
                PackedSymbolLists.</entry>
              </row>

              <row>
                <entry><code>RichSequenceBuilderFactor.THRESHOLD</code></entry>

                <entry>Will compress sequence data using a PackedSymbolList
                only when the sequence exceeds 5000 bases in length.
                Otherwise, data is not compressed.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>If you set the namespace to null, then the namespace used will
        depend on the format you are reading. For formats which specify
        namespaces, the namespace from the file will be used. For formats
        which do not specify namespaces, the default namespace provided by
        <code>RichObjectFactory.getDefaultNamespace()</code> will be
        used.</para>

        <para>The <code>SymbolTokenization</code> should be obtained from the
        Alphabet that represents the sequence data you are expecting from the
        file. If you are reading DNA sequences, you should use
        <code>DNATools.getDNA().getTokenization("token")</code>. Other
        alphabets with tools classes will have similar methods.</para>

        <para>For an alphabet which does not have a tools class, you can do
        this:</para>

        <programlisting>Alphabet a = ...; // get an alphabet instance from somewhere
SymbolTokenization st = a.getTokenization("token");</programlisting>
      </section>

      <section>
        <title>Writing using <code>RichStreamWriter</code>.</title>

        <para>File output is done using <code>RichStreamWriter</code>. This
        requires:</para>

        <orderedlist>
          <listitem>
            <para>an <code>OutputStream</code> to write sequences to.</para>
          </listitem>

          <listitem>
            <para>a <code>Namespace</code> to use for the sequences.</para>
          </listitem>

          <listitem>
            <para>a <code>RichSequenceIterator</code> that provides the
            sequences to write.</para>
          </listitem>
        </orderedlist>

        <para>The namespace should only be specified when the file format
        includes namespace information and you wish to override the
        information associated with the actual sequences. If you do not wish
        to do this, just set it to null, and the namespace from each
        individual sequence will be used instead.</para>

        <para>The <code>RichSequenceIterator</code> is an iterator over a set
        of sequences, exactly the same as the one returned by the
        <code>RichStreamReader</code>. It is therefore possible to plug a
        <code>RichStreamReader</code> directly into a
        <code>RichStreamWriter</code> and convert data from one file format to
        another with no intermediate steps.</para>

        <para>If you only have one sequence to write, you can wrap it in a
        temporary <code>RichSequenceIterator</code> by using a call like
        this:</para>

        <programlisting>RichSequence rs = ...; // get sequence from somewhere
RichSequenceIterator it = new SingleRichSeqIterator(rs); // wrap it in an iterator</programlisting>
      </section>

      <section>
        <title>Example.</title>

        <para>The following is an example that will read some DNA sequences
        from a GenBank file and write them out to standard output (screen) as
        FASTA using the methods outlined above:<programlisting>SymbolTokenization dna = DNATools.getDNA().getTokenization("token");        // sequences will be DNA sequences

RichSequenceFormat genbank = new GenbankFormat();                           // read Genbank
RichSequenceFormat fasta = new FastaFormat();                               // write FASTA
RichSequenceBuilderFactory factory = RichSequenceBuilderFactory.THRESHOLD;  // compress only longer sequences
Namespace bloggsNS = RichObjectFactory.getObject(
                        SimpleNamespace.class, 
                        new Object[]{"bloggs"} 
                     );                                                     // read/write everything using the 'bloggs' namespace

BufferedReader input = new BufferedReader(new FileReader("mygenbank.file"));// read seqs from "mygenbank.file"
OutputStream output = System.out;                                           // write seqs to STDOUT

RichStreamReader seqsIn = new RichStreamReader(input,genbank,dna,factory,bloggsNS);
RichStreamWriter seqsOut = new RichStreamWriter(output,fasta);
seqsOut.writeStream(seqsIn,bloggsNS);                                       // one-step Genbank to Fasta conversion!</programlisting></para>
      </section>

      <section>
        <title>Line widths and eliding information.</title>

        <para>When working at this level, extra methods can be used when
        direct access to the <code>RichSequenceFormat</code> object is
        available. These methods are:</para>

        <table>
          <title><code>RichSequenceFormat</code> extra options.</title>

          <tgroup cols="2">
            <tbody>
              <row>
                <entry><code>get/setLineWidth()</code></entry>

                <entry>Sets the line width for output. Any lines longer than
                this will be wrapped. The default for most formats is
                80.</entry>
              </row>

              <row>
                <entry><code>get/setElideSymbols()</code></entry>

                <entry>When set to true, this will skip the sequence data (ie.
                the addSymbols() method of the RichSeqIOListener will never be
                called).</entry>
              </row>

              <row>
                <entry><code>get/setElideFeatures()</code></entry>

                <entry>When set to true, this will skip the feature tables in
                the file.</entry>
              </row>

              <row>
                <entry><code>get/setElideComments()</code></entry>

                <entry>When set to true, this will skip all comments in the
                file.</entry>
              </row>

              <row>
                <entry><code>get/setElideReferences()</code></entry>

                <entry>When set to true, this will skip all publication
                cross-references in the file.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>Finer control is available when you go even deeper and write
        your own <code>RichSeqIOListener</code> objects. See later in this
        document for information on that subject. </para>
      </section>

      <section>
        <title>How parsed data becomes a sequence.</title>

        <para>All fields read from a file, regardless of the format, are
        passed to an instance of <code>RichSequenceBuilder</code>. In the case
        of the tools provided in <code>RichSequence.IOTools</code>, or any
        <code>RichStreamReader</code> using one of the
        <code>RichSequenceBuilderFactory</code> constants or
        <code>SimpleRichSequenceBuilderFactory</code>, this is an instance of
        <code>SimpleRichSequenceBuilder</code>.</para>

        <para><code>SimpleRichSequenceBuilder</code> constructs sequences as
        follows:<table>
            <title><code>SimpleRichSequenceBuilder</code> sequence
            construction.</title>

            <tgroup cols="2">
              <tbody>
                <row>
                  <entry><code>startSequence</code></entry>

                  <entry>Resets all the values in the builder to their
                  defaults, ready to parse a whole new sequence.</entry>
                </row>

                <row>
                  <entry><code>addSequenceProperty</code> </entry>

                  <entry>Assumes that both the key and the value of the
                  property are strings. It uses the key to look up a term with
                  the same name (case-sensitive) in the ontology provided by
                  <code>RichObjectFactory.getDefaultOntology()</code>. If it
                  finds no such term, it creates one. It then adds an
                  annotation to the sequence with that term as the key, using
                  the value provided. The first annotation receives the rank
                  of 0, the second 1, and so on. The annotations are attached
                  to the sequence using <code>setNoteSet()</code> and the
                  accumulated set of notes.</entry>
                </row>

                <row>
                  <entry><code>setVersion</code></entry>

                  <entry>Only accepts a single call per sequence. Value is
                  passed directly to the resulting sequence's
                  <code>setVersion</code> method.</entry>
                </row>

                <row>
                  <entry><code>setURI</code></entry>

                  <entry><emphasis>Not implemented, throws an
                  exception.</emphasis></entry>
                </row>

                <row>
                  <entry><code>setSeqVersion</code></entry>

                  <entry>Only accepts a single call per sequence. Value is
                  parsed into a double and passed to the resulting sequence's
                  <code>setSeqVersion</code> method. If the value is null,
                  then 0.0 is used.</entry>
                </row>

                <row>
                  <entry><code>setAccession</code></entry>

                  <entry>Value is passed directly to the sequence's
                  <code>setAccession</code> method. Multiple calls will
                  replace the accession, <emphasis>not</emphasis> add extra
                  ones. The accession cannot be null.</entry>
                </row>

                <row>
                  <entry><code>setDescription</code></entry>

                  <entry>Only accepts a single call per sequence. Value is
                  passed directly to the resulting sequence's
                  <code>setDescription</code> method.</entry>
                </row>

                <row>
                  <entry><code>setDivision</code></entry>

                  <entry>Only accepts a single call per sequence. Value is
                  passed directly to the resulting sequence's
                  <code>setDivision</code> method. The division cannot be
                  null.</entry>
                </row>

                <row>
                  <entry><code>setIdentifier</code></entry>

                  <entry>Only accepts a single call per sequence. Value is
                  passed directly to the resulting sequence's
                  <code>setIdentifier</code> method.</entry>
                </row>

                <row>
                  <entry><code>setName</code></entry>

                  <entry>Only accepts a single call per sequence. Value is
                  passed directly to the resulting sequence's
                  <code>setName</code> method.</entry>
                </row>

                <row>
                  <entry><code>setNamespace</code></entry>

                  <entry>Only accepts a single call per sequence. Value is
                  passed directly to the resulting sequence's
                  <code>setNamespace</code> method. The namespace cannot be
                  null.</entry>
                </row>

                <row>
                  <entry><code>setComment</code></entry>

                  <entry>Adds the text supplied (which must not be null) as a
                  comment to the sequence using <code>addComment()</code>.
                  Multiple calls will result in multiple comments being added.
                  The first comment is ranked 1, the second comment ranked 2,
                  and so on.</entry>
                </row>

                <row>
                  <entry><code>setTaxon</code></entry>

                  <entry>Value is passed to the sequence's
                  <code>setNamespace</code> method. It must not be null. If
                  this method is called repeatedly, only the first call will
                  be accepted. Subsequent calls will result in warnings being
                  printed to standard error. These extra calls will not cause
                  the builder to fail. The value from the initial call will be
                  the one that is used.</entry>
                </row>

                <row>
                  <entry><code>startFeature</code> </entry>

                  <entry>Tells the builder to start a new feature on this
                  sequence. If the current feature has not yet been ended,
                  then this feature will be a sub-feature of the current
                  feature and associated with it via a
                  <code>RichFeatureRelationship</code>, where the current
                  feature is the parent and this new feature is the child. The
                  relationship will be defined with the term "contains" from
                  <code>RichObjectFactory.getDefaultOntology()</code>. Each
                  feature will be attached to the resulting sequence by
                  calling <code>setParent()</code> on the feature once the
                  sequence has been created.</entry>
                </row>

                <row>
                  <entry><code>getCurrentFeature</code> </entry>

                  <entry>Returns the current feature, if one has been started.
                  If there is no current feature (eg. it has already ended, or
                  one was never started) then an exception is thrown.</entry>
                </row>

                <row>
                  <entry><code>addFeatureProperty</code> </entry>

                  <entry>Assumes that both the key and the value of the
                  property are strings. It uses the key to look up a term with
                  the same name (case-sensitive) in the ontology provided by
                  <code>RichObjectFactory.getDefaultOntology()</code>. If it
                  finds no such term, it creates one. It then adds an
                  annotation to the current feature with that term as the key,
                  using the value provided. The first annotation receives the
                  rank of 0, the second 1, and so on. The annotations are
                  attached to the feature using
                  <code>getAnnotation().addNote()</code>.</entry>
                </row>

                <row>
                  <entry><code>endFeature</code> </entry>

                  <entry>Ends the current feature. If there is no current
                  feature, an exception is thrown.</entry>
                </row>

                <row>
                  <entry><code>setRankedDocRef</code> </entry>

                  <entry>Adds the given <code>RankedDocRef</code> to the set
                  of publication cross-references which the sequence being
                  built refers to. The value cannot be null. If the same value
                  is provided multiple times, it will only be saved once. Each
                  value is stored by calling <code>addRankedDocRef()</code> on
                  the resulting sequence.</entry>
                </row>

                <row>
                  <entry><code>setRankedCrossRef</code></entry>

                  <entry>Adds the given <code>RankedCrossRef</code> to the set
                  of database cross-references which the sequence being built
                  refers to. The value cannot be null. If the same value is
                  provided multiple times, it will only be saved once. Each
                  value is stored by calling <code>addRankedCrossRef()</code>
                  on the resulting sequence.</entry>
                </row>

                <row>
                  <entry><code>setRelationship</code> </entry>

                  <entry>Adds the given <code>BioEntryRelationship</code> to
                  the set of relationships in which the sequence being built
                  is the parent. The relationship cannot be null. If the same
                  relationship is provided multiple times, it will only be
                  saved once. Each relationship is stored by calling
                  <code>addRelationship()</code> on the resulting
                  sequence.</entry>
                </row>

                <row>
                  <entry><code>setCircular</code> </entry>

                  <entry>You can call this as many times as you like. Each
                  call will override the value provided by the previous call.
                  The value is passed to the sequence's
                  <code>setCircular</code> method.</entry>
                </row>

                <row>
                  <entry><code>addSymbols</code></entry>

                  <entry>Adds symbols to this sequence. You can call it
                  multiple times to set symbols at different locations in the
                  sequence. If any of the symbols found are not in the
                  alphabet accepted by this builder, or if the locations
                  provided to place the symbols at are unacceptable, an
                  exception is thrown. The resulting <code>SymbolList</code>
                  will be the basis upon which the final
                  <code>RichSequence</code> object is built.</entry>
                </row>

                <row>
                  <entry><code>endSequence</code> </entry>

                  <entry>Tells the builder that we have provided all the
                  information we know. If at this point the name, namespace,
                  or accession have not been provided, or if any of them are
                  null, an exception is thrown.</entry>
                </row>

                <row>
                  <entry><code>makeSequence</code> </entry>

                  <entry>Constructs a <code>RichSequence</code> object from
                  the information provided, following the rules laid out in
                  this table, and returns it. The <code>RichSequence</code>
                  object does not actually exist until this method has been
                  called.</entry>
                </row>

                <row>
                  <entry><code>makeRichSequence</code></entry>

                  <entry>Wrapper for <code>makeSequence</code>.</entry>
                </row>
              </tbody>
            </tgroup>
          </table></para>

        <para>If you want fine-grained control over every aspect of a file
        whilst it is being parsed, you must write your own implementation of
        the <code>RichSeqIOListener</code> interface (which
        <code>RichSequenceBuilder</code> extends). This is detailed later in
        this document.</para>
      </section>
    </section>

    <section>
      <title>FASTA.</title>

      <para><code>FastaFormat</code> reads and writes FASTA files, and is able
      to parse the description line in detail.</para>

      <section>
        <title>Reading.</title>

        <para>The description line formats understood are as follows:</para>

        <programlisting>&gt;gi|&lt;identifier&gt;|&lt;namespace&gt;|&lt;accession&gt;.&lt;version&gt;|&lt;name&gt; &lt;description&gt;
&gt;gi|&lt;identifier&gt;|&lt;namespace&gt;|&lt;accession&gt;|&lt;name&gt; &lt;description&gt;

&gt;&lt;namespace&gt;|&lt;accession&gt;.&lt;version&gt;|&lt;name&gt; &lt;description&gt;
&gt;&lt;namespace&gt;|&lt;accession&gt;|&lt;name&gt; &lt;description&gt;

&gt;&lt;name&gt; &lt;description&gt;</programlisting>

        <para>The description is optional in all cases. The version defaults
        to 0 if not provided.</para>

        <para>If a non-null <code>Namespace</code> is provided, then the
        namespace in the file is ignored. </para>

        <para>If a null <code>Namespace</code> is provided, then the namespace
        from the file is used. If no namespace is specified in the file, then
        <code>RichObjectFactory.getDefaultNamespace()</code> is used.</para>

        <para>The fields are passed into the <code>RichSeqIOListener</code> as
        follows:</para>

        <table>
          <title><code>FastaFormat</code> input field destinations.</title>

          <tgroup cols="2">
            <tbody>
              <row>
                <entry>identifier</entry>

                <entry><code>setIdentifier()</code></entry>
              </row>

              <row>
                <entry>namespace</entry>

                <entry><code>setNamespace()</code></entry>
              </row>

              <row>
                <entry>accession</entry>

                <entry><code>setAccession()</code></entry>
              </row>

              <row>
                <entry>version</entry>

                <entry><code>setVersion()</code></entry>
              </row>

              <row>
                <entry>name</entry>

                <entry><code>setName()</code></entry>
              </row>

              <row>
                <entry>description</entry>

                <entry><code>setDescription()</code></entry>
              </row>

              <row>
                <entry>&lt;sequence data&gt;</entry>

                <entry><code>addSymbols()</code></entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>

      <section>
        <title>Writing.</title>

        <para>Description lines are always output in one of two forms:</para>

        <programlisting>&gt;gi|&lt;identifier&gt;|&lt;namespace&gt;|&lt;accession&gt;.&lt;version&gt;|&lt;name&gt; &lt;description&gt;
&gt;&lt;namespace&gt;|&lt;accession&gt;.&lt;version&gt;|&lt;name&gt; &lt;description&gt;</programlisting>

        <para>The first form is used if the identifier of the sequence object
        is not null, otherwise the second form is used. In both cases, the
        description is only output if it is not null.</para>

        <para>The fields are read from the <code>RichSequence</code> object as
        follows:</para>

        <table>
          <title><code>FastaFormat</code> output field sources.</title>

          <tgroup cols="2">
            <tbody>
              <row>
                <entry>identifier</entry>

                <entry><code>getIdentifier()</code></entry>
              </row>

              <row>
                <entry>namespace</entry>

                <entry><code>getNamespace()</code></entry>
              </row>

              <row>
                <entry>accession</entry>

                <entry><code>getAccession()</code></entry>
              </row>

              <row>
                <entry>version</entry>

                <entry><code>getVersion()</code></entry>
              </row>

              <row>
                <entry>name</entry>

                <entry><code>getName()</code></entry>
              </row>

              <row>
                <entry>description</entry>

                <entry><code>getDescription()</code></entry>
              </row>

              <row>
                <entry>&lt;sequence data&gt;</entry>

                <entry><code>RichSequence</code> is a
                <code>SymbolList</code>.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
    </section>

    <section>
      <title>GenBank.</title>

      <para><code>GenbankFormat</code> reads and writes GenBank files, and
      understands almost all permutations of the location descriptors found in
      the feature tables.</para>

      <section>
        <title>Reading.</title>

        <para>The fields are passed into the <code>RichSeqIOListener</code> as
        follows:</para>

        <table>
          <title><code>GenBankFormat</code> input field destinations.</title>

          <tgroup cols="2">
            <tbody>
              <row>
                <entry>LOCUS</entry>

                <entry>This line is split up into its component parts. The
                first word after the LOCUS keyword is passed to
                <code>setName()</code>. The strand, if present, is passed to
                <code>addSequenceProperty(Terms.getStrandedTerm())</code>. If
                it is circular, <code>setCircular()</code> is called. The
                molecule type is passed to
                <code>addSequenceProperty(Terms.getMolTypeTerm())</code>,
                whereas the modification date is passed to
                <code>addSequenceProperty(Terms.getDateUpdatedTerm())</code>.
                The database division is passed to
                <code>setDivision()</code>.</entry>
              </row>

              <row>
                <entry>DEFINITION</entry>

                <entry><code>setDescription()</code></entry>
              </row>

              <row>
                <entry>ACCESSION</entry>

                <entry>The first one is passed to <code>setAccession()</code>.
                Subsequent entries are passed to
                <code>addSequenceProperty(Terms.getAdditionalAccessionTerm())</code>.</entry>
              </row>

              <row>
                <entry>VERSION</entry>

                <entry>The section before the full stop "." is passed to
                <code>setAccession()</code>. If it differs from the first
                accession on the ACCESSION line, then the first accession on
                the ACCESSION line becomes an additional accession, whilst the
                accession from the VERSION line becomes the primary accession.
                The section after the full stop is passed to
                <code>setVersion()</code>. The GI number is passed to
                <code>setIdentifier()</code>.</entry>
              </row>

              <row>
                <entry>KEYWORDS</entry>

                <entry>The line is split up into individual keywords, each of
                which is passed to
                <code>addSequenceProperty(Terms.getKeywordTerm())</code>.</entry>
              </row>

              <row>
                <entry>SOURCE</entry>

                <entry>Ignored.</entry>
              </row>

              <row>
                <entry>ORGANISM</entry>

                <entry>Ignored.</entry>
              </row>

              <row>
                <entry>REFERENCE</entry>

                <entry>The coordinates of the reference end up as start and
                end coordinates of a <code>SimpleRankedDocRef</code> object
                which is attached to the sequence by calling
                <code>setRankedDocRef()</code>.</entry>
              </row>

              <row>
                <entry>AUTHORS</entry>

                <entry>The value is parsed into a set of
                <code>DocRefAuthor</code> objects using
                <code>DocRefAuthor.Tools</code>. The resulting set becomes
                part of the <code>DocRef</code> object which is wrapped using
                a <code>SimpleRankedDocRef</code> and attached to the
                sequence.</entry>
              </row>

              <row>
                <entry>TITLE</entry>

                <entry>The title is passed to the current <code>DocRef</code>
                object using <code>setTitle()</code>.</entry>
              </row>

              <row>
                <entry>JOURNAL</entry>

                <entry>The journal is passed to the current <code>DocRef
                </code>object using <code>setLocation()</code>.</entry>
              </row>

              <row>
                <entry>PUBMED</entry>

                <entry>A <code>RankedCrossRef</code> object is created
                pointing to <code>Terms.PUBMED_KEY</code> as the database, and
                using this value as the accession with a version of 0. It is
                attached to the sequence using
                <code>setRankedCrossRef()</code>. If no MEDLINE line is found,
                this is also associated with the current reference by using
                <code>setCrossRef()</code> on the <code>DocRef</code>
                object.</entry>
              </row>

              <row>
                <entry>MEDLINE</entry>

                <entry>Behaves similarly to PUBMED, but with a database name
                of <code>Terms.MEDLINE_KEY</code>. It takes precedence over
                PUBMED and will always be used for the <code>DocRef</code>
                cross-reference.</entry>
              </row>

              <row>
                <entry>REMARK</entry>

                <entry>Added to the current reference by calling
                <code>setRemark()</code> on the <code>DocRef</code>
                object.</entry>
              </row>

              <row>
                <entry>COMMENT</entry>

                <entry><code>setComment()</code></entry>
              </row>

              <row>
                <entry>FEATURES</entry>

                <entry>Each feature is started by calling
                <code>startFeature()</code>. The source is
                <code>Terms.getGenBankTerm()</code> whereas the type is
                obtained from
                <code>RichObjectFactory.getDefaultOntology().getOrCreateTerm()</code>
                using the feature name. Qualifiers are added by using
                <code>addFeatureProperty()</code> with the term key created by
                <code>RichObjectFactory.getDefaultOntology().getOrCreateTerm()</code>
                using the qualifier name. There are two special cases of
                qualifier: <code>db_xref</code>, and <code>organism</code>.
                Neither end up being stored as qualifiers. A database
                cross-reference is created for <code>db_xref</code> qualifiers
                and added to the feature using
                <code>addRankedCrossRef()</code>, except when the feature type
                is <code>source</code> and the database name (before the
                colon) is <code>taxon</code>, in which case the taxon ID is
                used in conjunction with the <code>organism</code> qualifier
                to determine the <code>NCBITaxon</code> for this sequence, and
                passed to the sequence using <code>setTaxon()</code>. Location
                strings are run through <code>GenBankLocationParser</code> to
                generate <code>RichLocation</code> instances to attach to the
                feature.</entry>
              </row>

              <row>
                <entry>BASE</entry>

                <entry>Ignored.</entry>
              </row>

              <row>
                <entry>ORIGIN</entry>

                <entry>The sequence is read and passed to
                <code>addSymbols()</code>.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>

      <section>
        <title>Writing.</title>

        <para>The fields are read from the <code>RichSequence</code> object as
        follows:</para>

        <table>
          <title><code>GenBankFormat</code> output field sources.</title>

          <tgroup cols="2">
            <tbody>
              <row>
                <entry>LOCUS</entry>

                <entry><code>getName()</code>, <code>length()</code>,
                <code>getNoteSet(Terms.getStrandedTerm())</code>,
                <code>getNoteSet(Terms.getMolTypeTerm())</code>,
                <code>getCircular()</code>, <code>getDivision()</code>, and
                <code>getNoteSet(Terms.getDateUpdatedTerm())</code></entry>
              </row>

              <row>
                <entry>DEFINITION</entry>

                <entry><code>getDescription()</code></entry>
              </row>

              <row>
                <entry>ACCESSION</entry>

                <entry><code>getAccession()</code>, and
                <code>getNoteSet(Terms.getAdditionalAccessionTerm())</code>.</entry>
              </row>

              <row>
                <entry>VERSION</entry>

                <entry><code>getAccession()</code>,
                <code>getIdentifier()</code> and
                <code>getVersion()</code></entry>
              </row>

              <row>
                <entry>KEYWORDS</entry>

                <entry><code>getNoteSet(Terms.getKeywordTerm())</code>.</entry>
              </row>

              <row>
                <entry>SOURCE</entry>

                <entry><code>getNCBITaxon().getDisplayName()</code></entry>
              </row>

              <row>
                <entry>ORGANISM</entry>

                <entry><code>getNCBITaxon()getDisplayName()</code>, chopped
                before the first bracket, and
                <code>getNCBITaxon().getNameHierarchy()</code></entry>
              </row>

              <row>
                <entry>REFERENCE</entry>

                <entry>Each reference is obtained from
                <code>getRankedDocRefs()</code>. The coordinates of the
                reference are from the reference's <code>getStart()</code> and
                <code>getEnd()</code> methods.</entry>
              </row>

              <row>
                <entry>AUTHORS</entry>

                <entry>The author string is from the reference's
                <code>getAuthors()</code> method.</entry>
              </row>

              <row>
                <entry>TITLE</entry>

                <entry>The title is from the reference's
                <code>getTitle()</code>.</entry>
              </row>

              <row>
                <entry>JOURNAL</entry>

                <entry>The journal information is from the reference's
                <code>getLocation()</code>.</entry>
              </row>

              <row>
                <entry>PUBMED / MEDLINE</entry>

                <entry>The cross reference returned by
                <code>getCrossRef()</code> on the reference provides the
                database name and accession used here. </entry>
              </row>

              <row>
                <entry>REMARK</entry>

                <entry><code>getRemark()</code> on the current reference
                object.</entry>
              </row>

              <row>
                <entry>COMMENT</entry>

                <entry>All the comments returned by <code>getComments()</code>
                are joined together, separated by newlines.</entry>
              </row>

              <row>
                <entry>FEATURES</entry>

                <entry>Each feature is output in turn by iterating through
                <code>getFeatureSet()</code>. For the <code>source
                </code>feature, the <code>db_xref</code> and
                <code>organism</code> fields are added to the output by
                calling <code>getNCBITaxon().getNCBITaxID()</code> and
                <code>getNCBITaxon().getDisplayName()</code> on the sequence
                (the latter is chopped before the first bracket if necessary).
                For all features, extra <code>db_xref</code> qualifiers are
                output for each cross-reference returned by calling
                <code>getRankedCrossRefs()</code> on the feature. The other
                qualifiers for the features are the contents of the feature's
                annotation, provided by <code>getNoteSet()</code> on the
                feature. <code>GenBankLocationParser</code> is used to convert
                the feature's <code>getLocation()</code> output into the
                correct text format.</entry>
              </row>

              <row>
                <entry>BASE</entry>

                <entry>Calculated from the sequence data.</entry>
              </row>

              <row>
                <entry>ORIGIN</entry>

                <entry>The sequence is read directly as it is a
                <code>SymbolList</code>..</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
    </section>

    <section>
      <title>EMBL.</title>

      <para><code>EMBLFormat</code> reads and writes GenBank files, and
      understands almost all permutations of the location descriptors found in
      the feature tables. </para>

      <section>
        <title>Reading.</title>

        <para>The fields are passed into the <code>RichSeqIOListener</code> as
        follows: </para>

        <table>
          <title><code>EMBLFormat</code> input field destinations.</title>

          <tgroup cols="2">
            <tbody>
              <row>
                <entry>ID</entry>

                <entry><code>setName()</code>,
                <code>addSequenceProperty(Terms.getMolTypeTerm())</code>,
                <code>setDivision()</code>, <code>setCircular()</code></entry>
              </row>

              <row>
                <entry>AC</entry>

                <entry>First accession goes to <code>setAccession()</code>,
                all others to
                <code>addSequenceProperty(Terms.getAdditionalAccessionTerm())</code>.</entry>
              </row>

              <row>
                <entry>SV</entry>

                <entry>If the accession (before the full stop ".") is
                different from the first accession on the AC line, then this
                accession becomes the primary accession, and the first
                accession on the AC line becomes an additional accession.
                Everything after the full stop goes to
                <code>setVersion()</code>. </entry>
              </row>

              <row>
                <entry>DE</entry>

                <entry><code>setDescription()</code></entry>
              </row>

              <row>
                <entry>DT</entry>

                <entry>For creation date:
                <code>addSequenceProperty(Terms.getDateCreatedTerm())</code>
                and
                <code>addSequenceProperty(Terms.getRelCreatedTerm())</code>.
                For last updated date:
                <code>addSequenceProperty(Terms.getDateUpdatedTerm())</code>
                and
                <code>addSequenceProperty(Terms.getRelUpdatedTerm())</code>.</entry>
              </row>

              <row>
                <entry>DR</entry>

                <entry>Each record is split into a database name, primary
                accession, and additional accessions. A <code>CrossRef</code>
                object is constructed from these first two pieces, and
                annotated with additional accessions using
                <code>Terms.getAdditionalAccessionTerm()</code>. The whole
                thing is then given a rank and sent to
                <code>setRankedCrossRef()</code>.</entry>
              </row>

              <row>
                <entry>OS</entry>

                <entry>Ignored.</entry>
              </row>

              <row>
                <entry>OC</entry>

                <entry>Ignored.</entry>
              </row>

              <row>
                <entry>OG</entry>

                <entry><code>addSequenceProperty(Terms.getOrganelleTerm())</code></entry>
              </row>

              <row>
                <entry>RN</entry>

                <entry>The number of the reference becomes the rank of the
                <code>RankedDocRef</code> object later.</entry>
              </row>

              <row>
                <entry>RP</entry>

                <entry>The values on this line become the start and end of the
                <code>RankedDocRef</code> object later.</entry>
              </row>

              <row>
                <entry>RX</entry>

                <entry>Each of these is parsed and the database name and
                primary accession are used to construct a
                <code>CrossRef</code> object. All <code>CrossRef</code>
                objects are ranked and added to the sequence
                <code>setRankedCrossRef()</code>, and one of them will be
                added to the current reference using
                <code>setCrossRef()</code>. The one that is chosen will be
                MEDLINE, or PUBMED if not present, or DOI if PUBMED not
                present either.</entry>
              </row>

              <row>
                <entry>RA</entry>

                <entry>Parsed using <code>DocRefAuthor.Tools.parse()</code>
                and becomes the set of authors for the <code>DocRef</code>
                object.</entry>
              </row>

              <row>
                <entry>RG</entry>

                <entry>Parsed using <code>DocRefAuthor.Tools.parse()</code>,
                and each consortium is flagged using the
                <code>setConsortium()</code> method before being added to the
                set of authors for the <code>DocRef</code> object.</entry>
              </row>

              <row>
                <entry>RT</entry>

                <entry>The title for <code>setTitle()</code> on the
                <code>DocRef</code> object.</entry>
              </row>

              <row>
                <entry>RL</entry>

                <entry>The location for the <code>setLocation()</code> method
                on the <code>DocRef</code> object.</entry>
              </row>

              <row>
                <entry>RC</entry>

                <entry>Used for <code>setRemark()</code> on the
                <code>DocRef</code> object.</entry>
              </row>

              <row>
                <entry>KW</entry>

                <entry>Each keyword is sent individually to
                <code>addSequenceProperty(Terms.getKeywordTerm())</code></entry>
              </row>

              <row>
                <entry>CC</entry>

                <entry><code>setComment()</code></entry>
              </row>

              <row>
                <entry>FH</entry>

                <entry>Ignored.</entry>
              </row>

              <row>
                <entry>FT</entry>

                <entry>As per the GenBankFormat - please see the section on
                GenBank parsing.</entry>
              </row>

              <row>
                <entry>CO</entry>

                <entry>Causes an exception as contigs are not
                supported.</entry>
              </row>

              <row>
                <entry>AH</entry>

                <entry>Causes an exception as TPAs are not supported.</entry>
              </row>

              <row>
                <entry>SQ</entry>

                <entry>Sequence data is passed to
                <code>addSymbols()</code>.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>

      <section>
        <title>Writing.</title>

        <para>The fields are read from the <code>RichSequence</code> object as
        follows:</para>

        <table>
          <title><code>EMBLFormat</code> output field sources.</title>

          <tgroup cols="2">
            <tbody>
              <row>
                <entry>ID</entry>

                <entry><code>getName()</code>,
                <code>getNoteSet(Terms.getMolTypeTerm())</code>,
                <code>getDivision()</code>, <code>getCircular()</code></entry>
              </row>

              <row>
                <entry>AC</entry>

                <entry><code>getAccession()</code>, and
                <code>getNoteSet(Terms.getAdditionalAccessionTerm())</code>.</entry>
              </row>

              <row>
                <entry>SV</entry>

                <entry><code>getAccession()</code> and
                <code>getVersion()</code>.</entry>
              </row>

              <row>
                <entry>DE</entry>

                <entry><code>getDescription()</code></entry>
              </row>

              <row>
                <entry>DT</entry>

                <entry>For creation date:
                <code>getNoteSet(Terms.getDateCreatedTerm())</code> and
                <code>getNoteSet(Terms.getRelCreatedTerm())</code>. For last
                updated date:
                <code>getNoteSet(Terms.getDateUpdatedTerm())</code> and
                <code>getNoteSetTerms.getRelUpdatedTerm())</code>.</entry>
              </row>

              <row>
                <entry>DR</entry>

                <entry><code>getRankedCrossRef()</code>, using
                <code>getNoteSet(Terms.getAdditionalAccessionTerm())</code> to
                generate additional accessions.</entry>
              </row>

              <row>
                <entry>OS</entry>

                <entry><code>getNCBITaxon().getDisplayName()</code></entry>
              </row>

              <row>
                <entry>OC</entry>

                <entry><code>getNCBITaxon()getDisplayName()</code>, chopped
                before the first bracket, and
                <code>getNCBITaxon().getNameHierarchy()</code>.</entry>
              </row>

              <row>
                <entry>OG</entry>

                <entry><code>getNoteSet(Terms.getOrganelleTerm())</code></entry>
              </row>

              <row>
                <entry>RN</entry>

                <entry>Each reference returned by
                <code>getRankedDocRefs()</code> is iterated over. The rank of
                the <code>RankedDocRef</code> object is output here.</entry>
              </row>

              <row>
                <entry>RP</entry>

                <entry>The start and end coordinates of the
                <code>RankedDocRef</code> object.</entry>
              </row>

              <row>
                <entry>RX</entry>

                <entry>The <code>getCrossRef()</code> output from the
                <code>DocRef</code> object.</entry>
              </row>

              <row>
                <entry>RA</entry>

                <entry>The <code>getAuthors()</code> output from the
                <code>DocRef</code> object, with the consortiums
                removed.</entry>
              </row>

              <row>
                <entry>RG</entry>

                <entry>The <code>getAuthors()</code> output from the
                <code>DocRef</code> object, with all except consortiums
                removed.</entry>
              </row>

              <row>
                <entry>RT</entry>

                <entry>The <code>getTitle()</code> from the
                <code>DocRef</code>.</entry>
              </row>

              <row>
                <entry>RL</entry>

                <entry>The <code>getLocation()</code> from the
                <code>DocRef</code>.</entry>
              </row>

              <row>
                <entry>RC</entry>

                <entry>The <code>getRemark()</code> from the
                <code>DocRef</code>.</entry>
              </row>

              <row>
                <entry>KW</entry>

                <entry><code>getNoteSet(Terms.getKeywordTerm())</code>.</entry>
              </row>

              <row>
                <entry>CC</entry>

                <entry>One comment section per entry in
                <code>getComments()</code>.</entry>
              </row>

              <row>
                <entry>FH</entry>

                <entry>No fields necessary here.</entry>
              </row>

              <row>
                <entry>FT</entry>

                <entry>As per the GenBankFormat - please see the section on
                GenBank parsing.</entry>
              </row>

              <row>
                <entry>CO</entry>

                <entry>Never generated.</entry>
              </row>

              <row>
                <entry>AH</entry>

                <entry>Never generated.</entry>
              </row>

              <row>
                <entry>SQ</entry>

                <entry>Sequence counts are generated, then sequence is read
                directly as it is a <code>SymbolList</code>.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
    </section>

    <section>
      <title>UniProt.</title>

      <para><code>UniProtFormat</code> documentation coming soon.</para>
    </section>

    <section>
      <title>INSDSeq (XML).</title>

      <para>For parsing files that conform to
      <code>http://www.ebi.ac.uk/embl/Documentation/DTD/INSDSeq_v1.3.dtd.txt</code>.</para>

      <para><code>INSDSeqFormat</code> documentation coming soon.</para>
    </section>

    <section>
      <title>EMBLxml (XML).</title>

      <para>For parsing files that conform to
      <code>http://www.ebi.ac.uk/embl/Documentation/DTD/EMBL_dtd.txt</code>.</para>

      <para><code>EMBLxmlFormat</code> documentation coming soon.</para>
    </section>

    <section>
      <title>UniProtXML (XML).</title>

      <para>For parsing files that conform to
      <code>http://www.ebi.uniprot.org/support/docs/uniprot.xsd</code>.</para>

      <para><code>UniProtXMLFormat</code> documentation coming soon.</para>
    </section>

    <section>
      <title>NCBI Taxonomy data.</title>

      <para>The NCBI taxonomy loader operates outside the standed file parsing
      framework, as it is not dealing with a single file and does not generate
      sequence objects. Instead, it provides separate functions for reading
      the <code>nodes.dmp</code> and <code>names.dmp</code> files
      line-by-line, and returning the corresponding <code>NCBITaxon</code>
      object for each line of the file. An example to load the taxonomy data
      follows:</para>

      <programlisting>NCBITaxonomyLoader l = new SimpleNCBITaxonomyLoader();
BufferedReader nodes = new BufferedReader(new FileReader("nodes.dmp"));
BufferedReader names = new BufferedReader(new FileReader("names.dmp"));
        
NCBITaxon t;
while ((t=l.readNode(nodes))!=null);  // read all the nodes first
while ((t=l.readName(names))!=null);  // then read all the names 

// if your LRU cache is big enough, it'll now hold fully-populated instances 
// of all the taxon objects. Not much use unless you're using a database!</programlisting>

      <para>Note that this is most effective when using BioJavaX with
      Hibernate to persist data to the database. You do not need to do
      anything apart from wrap the above code in a transaction, and it will be
      persisted for you.</para>

      <para>Note that you may have trouble with duplicate
      <code>NCBITaxon</code> objects or names going missing if you have an LRU
      cache in <code>RichObjectFactory</code> that is too small. This issue is
      avoided altogether when using the
      <code>HibernateRichObjectFactory</code>. </para>
    </section>
  </chapter>

  <chapter>
    <title>Creative file parsing with <code>RichSeqIOListener</code>.</title>

    <section>
      <title>Using <code>RichSeqIOListener</code>s directly.</title>

      <para>In order to do creative file parsing, you need to start using very
      low level BioJava APIs. This involves setting up a RichSeqIOListener and
      allowing it to communicate directly with the RichSequenceFormat
      instances that parse files. You have to choose whether you want just to
      listen to data as it is read from the file, or whether you want to use
      these events to construct a RichSequence object. </para>

      <section>
        <title>Listening to events only.</title>

        <para>You need to write a class which implements
        <code>RichSeqIOListener</code>. The easiest way to do this is to
        extend <code>RichSeqIOAdapter</code>, which is a very simple
        implementation which ignores everything and returns dummy empty
        features whenever <code>getCurrentFeature()</code> is called.</para>

        <para>You can then use your class like this (see the earlier section
        on <code>RichStreamReader</code> for how to construct the various
        other objects required):</para>

        <programlisting>BufferedReader input = ...;       // your input file
Namespace ns = ...;               // the namespace to read sequences into 
SymbolTokenization st = ...;      // the tokenization used to parse sequence data

RichSeqIOListener listener = ...; // your custom listener object

boolean moreSeqsAvailable = true; // assume there is at least one sequence in the file
while (moreSeqsAvailable) {
     moreSeqsAvailable = format.readRichSequence(input, st, listener, ns);
     // your listener will have received all the information for the current sequence by this stage
}</programlisting>
      </section>

      <section>
        <title>Constructing sequences from events.</title>

        <para>You need to write a class which implements both
        <code>RichSeqIOListener</code> and <code>RichSequenceBuilder</code>.
        Again you could just extend <code>RichSeqIOAdapter</code>, and
        implement the extra methods required by
        <code>RichSequenceBuilder</code> to make it fully functional. You will
        obviously need to store information passed to your instance as parsing
        goes along, in order to be able to construct the sequence objects when
        <code>makeRichSequence()</code> is called at the end.</para>

        <para>Your <code>RichSequenceBuilder</code> is now fully compatible
        with the <code>RichStreamReader</code> framework outlined earlier in
        this document, but you will also need to create a
        <code>RichSequenceBuilderFactory</code> implementation to work with
        it. The simplest form of such a factory (assuming a custom builder
        named <code>CustomRichSequenceBuilder</code>) looks like this:</para>

        <programlisting>public class CustomRichSequenceBuilderFactory implements RichSequenceBuilderFactory {
    public CustomRichSequenceBuilderFactory() {}
    public SequenceBuilder makeSequenceBuilder() {
        return new CustomRichSequenceBuilder();
    }
}</programlisting>
      </section>
    </section>

    <section>
      <title>Parsing only specific fields.</title>

      <para>The basic <code>RichSeqIOAdapter</code> class ignores all data
      passed to it. This is the simplest form of a
      <code>RichSeqIOListener</code>. Building from this base, you can
      construct specialist <code>RichSeqIOListener</code> implementations that
      perform very specific tasks very efficiently. For instance, a listener
      that counts all the sequences in a file would look like this:</para>

      <programlisting>public class MyListener extends RichSeqIOAdapter {
    private int seqCount;
    public MyListener() { 
        super();
        this.seqCount = 0;
    }
    public void startSequence() { this.seqCount++; }
    public void getSeqCount() { return this.seqCount; }
}</programlisting>

      <para>You could then call <code>getSeqCount()</code> on this class after
      parsing a file to find out exactly how many sequences it
      contained.</para>
    </section>
  </chapter>

  <chapter>
    <title>Publication cross-references.</title>

    <section>
      <title>Everything is a 'journal article'.</title>

      <para>Owing to the way in which BioSQL stores publication
      cross-references, there is no way to distinguish between different types
      of publication. This is mirrored in the BioJavaX object model in the
      <code>DocRef</code> interface.</para>

      <para>As journal articles are the most common type of publication
      cross-reference, everything is assumed by BioJavaX to be a journal
      article. </para>

      <para>BioJavaX makes no attempt to parse information out from textual
      publication location descriptions (eg. the LOCATION line in GenBank
      files). Likewise, when it encounters XML publication location
      descriptions (such as those found in UniProtXML) it merely concatenates
      all the data together into a single string. When writing out in XML
      format it always uses the plain-text option wherever possible unless
      forced to use the journal-article specific option by an XML DTD. These
      descriptions are stored using <code>setLocation()</code> on the
      <code>DocRef</code> object.</para>

      <para>The only piece of information which it attempts to parse (other
      than the title) is the author data. It parses each author into a
      <code>DocRefAuthor</code>, and stores a set of these with each
      <code>DocRef</code> object. Tools are provided in
      <code>DocRefAuthor.Tools</code> for converting these sets to/from a
      single string for use in situations such as the AUTHOR tag in GenBank
      files, or when persisting to a BioSQL database.</para>

      <para><code>DocRef</code> instances must be wrapped in a
      <code>RankedDocRef</code> before they can be associated with a sequence
      via <code>addRankedDocRef()</code>. The usual default rank is 0.</para>
    </section>

    <section>
      <title>Editors and consortiums as authors.</title>

      <para>When dealing in plain text, authors who are editors are suffixed
      with " (ed.)". Authors who are consortiums are suffixed with "
      (consortium)". The <code>DocRefAuthor.Tools</code> parses these suffixes
      (in any order) and uses <code>setEditor()</code> and
      <code>setConsortium()</code> on the <code>DocRefAuthor</code> object to
      indicate what it found. When converting <code>DocRefAuthor</code>
      objects to plain text it will also append these suffixes as
      necessary.</para>
    </section>
  </chapter>

  <chapter>
    <title>Database cross-references.</title>

    <section>
      <title>Database names.</title>

      <para>Cross-references to other databases are defined as
      <code>CrossRef</code> objects. To associate a cross-reference with a
      particular sequence, you need to assign it a rank before adding it to
      the sequence using <code>addRankedCrossRef()</code>. To do this, wrap it
      in a <code>RankedCrossRef</code> object.</para>

      <para>Database names are case-sensitive. When using cross-references, be
      very aware of this. The various file parsers do not make much effort to
      convert the database names they find to a single case policy, as several
      of the formats insist on different ones. </para>

      <para>If you will be persisting lots of new data regularly to your
      datbase, keep an eye on this. Some kind of SQL script to do a periodic
      tidy-up might be handy. If you come up with one and feel it would be
      useful for others too, please feel free to send it in and we'll add it
      below.</para>

      <para>Common database names can be found as constants (eg.
      <code>PUBMED_KEY</code>) in <code>RichSequence.Terms</code>.</para>
    </section>

    <section>
      <title>Accessions and versions.</title>

      <para>All database cross-references have at least one accession, which
      is the primary accession for that reference. The version is also
      compulsory, although often it is just left as zero. Only primary
      accessions have explicitly separate versions - secondary or tertiary
      accessions, if they have versions at all, will have the versions
      included in the accession itself.</para>

      <para>Secondary, ternary, quaternary etc. accessions are stored as
      annotations on the cross-reference. These secondary accession
      annotations must all have the key
      <code>RichSequence.Terms.getAdditionalAccessionTerm()</code> if they are
      to be understood across all parts of BioJavaX.</para>
    </section>
  </chapter>

  <chapter>
    <title>Working with <code>RichLocation</code> objects.</title>

    <section>
      <title>Working with locations.</title>

      <para>In BioJavaX, all locations are instances of classes which
      implement the RichLocation interface. These are very complex objects, so
      need to be used with care. </para>

      <para>All locations use Position objects to define their end points.
      Position objects have a start coordinate, and for fuzzy ones an end
      coordinate too along with a symbol indicating what kind of range the two
      points encompass (eg. the "." or "^" symbols from GenBank-style
      locations). If the start or end coordinate of a fuzzy position is fuzzy
      in itself (eg. "&lt;" or "&gt;" from GenBank-style locations), then
      flags can be set on the object to indicate this.</para>

      <para>Locations have ranks which are used to sort them. If persisted to
      a database, the complex location that results when retrieving them from
      the database will be ordered by rank.</para>

      <para>The simplest kind of location describes a single point or range
      between two points on a sequence, with optional fuzziness at either end.
      This is implemented by the SimpleRichLocation class. </para>

      <para>This example describes the GenBank-style location string
      "56":</para>

      <programlisting>Position pos = new SimplePosition(56);  
RichLocation loc = new SimpleRichLocation(pos,0);   // the 0 is an arbitrary value for the rank of this location</programlisting>

      <para>This example describes the GenBank-style location string
      "(23^34)..57&gt;":</para>

      <programlisting>Position min = new SimplePosition(false,false,23,34,"^"); // two falses = not fuzzy at all
Position max = new SimplePosition(false,true,57);         // false = non-fuzzy start, true = fuzzy end
RichLocation loc = new SimpleRichLocation(min,max,0);     // the 0 is an arbitrary value for the rank of this location</programlisting>

      <para>This example describes the GenBank-style location string
      "complement((23^34)..57&gt;)":</para>

      <programlisting>Position min = new SimplePosition(false,false,23,34,"^"); // two falses = not fuzzy at all
Position max = new SimplePosition(false,true,57);         // false = non-fuzzy start, true = fuzzy end
RichLocation loc = new SimpleRichLocation(min,max,0,Strand.NEGATIVE_STRAND); </programlisting>

      <para>This example describes the GenBank-style location string
      "A12345.3:complement((23^34)..57&gt;)":</para>

      <programlisting>CrossRef cr = new SimpleCrossRef("GenBank","A12345",3);   // version 3 of accession A12345 in the GenBank database
Position min = new SimplePosition(false,false,23,34,"^"); // two falses = not fuzzy at all
Position max = new SimplePosition(false,true,57);         // false = non-fuzzy start, true = fuzzy end
RichLocation loc = new SimpleRichLocation(min,max,Strand.NEGATIVE_STRAND,cr);</programlisting>

      <para>If you require locations that cover more than one range, you
      <emphasis>must</emphasis> use the <code>RichLocation.Tools</code>
      methods to help you. If you don't, you run a serious risk of making
      nonsense locations that will give unpredictable results.</para>

      <para>A complex location is constructed from a collection of
      <code>RichLocation</code> instances. Any member of the collection which
      is already a complex location is flattened out into its member
      <code>SimpleRichLocation</code> objects first (see later section on
      flattening locations) before the new location is constructed. The
      construction process attempts to minimise the number of these simple
      locations by merging the ones that overlap. Therefore the total number
      of member locations (blocks) in the resulting complex location may be
      less than the number of locations you originally passed in as
      input.</para>

      <para>To construct a complex location from a set of existing
      <code>RichLocation</code> instances, follow this example:</para>

      <programlisting>RichLocation first = ...;   // some arbitrary location
RichLocation second = ...;  // some other location
Collection members = Arrays.asList(new RichLocation[]{first,second});
RichLocation combined = RichLocation.Tools.construct(members);</programlisting>

      <para>The <code>construct()</code> method will return one of four
      different types of <code>RichLocation</code> objects, depending on the
      members passed in:</para>

      <table>
        <title><code>RichLocation.Tools.construct()</code> result
        types.</title>

        <tgroup cols="2">
          <tbody>
            <row>
              <entry><code>EmptyRichLocation</code></entry>

              <entry>If the input collection was empty, or only contained a
              single entry which was an instance of
              <code>EmptyRichLocation</code> itself.</entry>
            </row>

            <row>
              <entry><code>SimpleRichLocation</code></entry>

              <entry>If all the members in the input collection overlap and
              are on the same strand of the same sequence, the result will be
              a single location covering the entire overlapping range.</entry>
            </row>

            <row>
              <entry><code>CompoundRichLocation</code></entry>

              <entry>If all the members in the input collection are on the
              same strand of the same sequence, but after merging overlapping
              locations there are still gaps, then a
              <code>CompoundRichLocation</code> is returned containing one
              <code>SimpleRichLocation</code> per merged region. All the
              members are guaranteed to be on the same strand of the same
              sequence. The strand and cross-ref of the location returned will
              be consistent with its members. The min and max of the location
              will correspond to the min and max of all the members
              combined.</entry>
            </row>

            <row>
              <entry><code>MultiSourceCompoundRichLocation</code></entry>

              <entry>As per <code>CompoundRichLocation</code>, but members may
              appear on different strands or even different (remote)
              sequences. The min, max, strand and cross-ref of the location
              returned are meaningless, and should not be used. You should
              instead interrogate each member location (block) for this
              information as required.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>Strandedness.</title>

      <para>All <code>SimpleRichLocation</code> and
      <code>CompoundRichLocation</code> objects have a strand assigned to
      them. The various strands available are defined as constants in
      <code>RichLocation.Strand</code>. If two locations have different
      strands, then they will never be found together in the same
      <code>CompoundRichLocation</code>, but they may occur together in a
      <code>MultiSourceCompoundRichLocation</code>.</para>

      <para>In all cases, location coordinates are given w.r.t. the 5' end of
      the positive strand, with the first base numbered as 1. This is to make
      overlap, union, and intersection calculations easier.</para>
    </section>

    <section>
      <title>Remote locations.</title>

      <para>Locations are generally sequence-agnostic until they are applied
      to a specific sequence, usually through a feature. However, some
      locations specifically refer to an individual sequence, and are assigned
      a <code>CrossRef</code> instance to indicate this. These are remote
      locations. A null value indicates that the location is not
      remote.</para>

      <para>The sequences backing remote locations are retrieved using a
      <code>CrossReferenceResolver</code>, the default one being supplied by
      <code>RichObjectFactory.getDefaultCrossReferenceResolver()</code>. You
      can override the use of this default either by changing the default in
      the <code>RichObjectFactory</code>, or calling
      <code>setCrossReferenceResolver()</code> directly on the location
      object.</para>

      <para>The job of this resolver is to obtain sequence data for the remote
      sequence. If the resolver cannot locate the sequence, the location may
      throw an exception when any operation requiring the services of the
      resolver is attempted.</para>

      <para>If you are using a database with BioJavaX and that sequence is to
      be found in the same database, then make sure that the database name
      given to the <code>CrossRef</code> instance is the same as the
      <emphasis>namespace</emphasis> of the sequence in your database, and
      that the accessions and versions are the same.</para>
    </section>

    <section>
      <title>Resolving fuzziness.</title>

      <para>Fuzziness is all well and good until you try and work out whether
      one sequence overlaps another, or try and store the location in a
      database like BioSQL that has no concept of fuzziness. In these kinds of
      situation, you have to resolve the fuzziness to a specific coordinate
      before you can use it.</para>

      <para>Locations will resolve positions as necessary using the position
      resolver supplied by
      <code>RichObjectFactory.getDefaultPositionResolver()</code>. You can
      replace this default resolver for all locations by using the appropriate
      methods in <code>RichObjectFactory</code>, or you can change it for this
      location only by calling <code>setPositionResolver()</code> on the
      location object. A number of useful ones are provided as sub-classes of
      the <code>PositionResolver</code> interface.</para>
    </section>

    <section>
      <title>Translation.</title>

      <para>Locations can be moved left or right by a fixed number of bases by
      using the <code>translate()</code> method. This method returns a new
      location with all members offset by the value specified. A negative
      offset will move locations towards the 5' end of the positive strand,
      whilst a positive offset will move them towards the 3' end.</para>
    </section>

    <section>
      <title>Empty locations.</title>

      <para>The empty location is represented by a singleton instance of
      <code>EmptyRichLocation</code>, available as a constant as
      <code>RichLocation.EMPTY_LOCATION</code>.</para>
    </section>

    <section>
      <title>Circular locations.</title>

      <para>Locations are circular if a call is made to
      <code>setCircularLength()</code> with a value greater than zero. The
      value indicates the length of the circular sequence that this location
      overlays. This is important when it comes to calculating overlaps,
      unions and other operations where the wrap-around point for the
      coordinates must be known.</para>

      <para>A circular location cannot be applied to a non-circular sequence.
      Neither can it be applied to a circular sequence with a length that is
      not the same as the one returned by the <code>getCircularLength()</code>
      method of the location.</para>

      <para>The concept of circularity is not understood by BioSQL, so this
      information will be lost if you persist it to a database.</para>
    </section>

    <section>
      <title>Union.</title>

      <para>The union of any two locations X and Y that do not overlap (see
      section on overlapping locations), or that overlap but on different
      strands, is simply a complex location with X and Y as members.</para>

      <para>The union of two linear locations X and Y that overlap on the same
      strand is a single simple location that covers the entire area from
      X.min to Y.max.</para>

      <para>The union of circular location X with any other location Y that
      overlaps on the same strand is a single simple location that covers the
      region from the 5' most of X.min and Y.min to the 3' most of X.max and
      Y.max w.r.t. the positive strand.</para>

      <para>Complex locations will perform the above steps on each pair of
      member locations in turn, and the union will be the combination set of
      all unique locations that these pair-wise intersections produce. Any
      overlapping locations on the same strand within this set will be merged
      into single, larger locations.</para>
    </section>

    <section>
      <title>Intersection.</title>

      <para>Locations never intersect if they do not overlap (see section on
      overlapping locations). The intersection operation will return the empty
      location.</para>

      <para>If two linear locations X and Y overlap each other on the same
      strand, then the intersection is a single simple location covering the
      overlapping region.</para>

      <para>If any two locations X and Y overlap each other on different
      strands, then the intersection is a complex location containing only the
      portions of X and Y that overlap each other.</para>

      <para>If a circular location X overlaps any other location Y on the same
      strand, then the resulting single simple circular location will cover
      the region from the 3' most of X.min and Y.min to the 5' most of X.max
      and Y.max w.r.t. the positive strand.</para>

      <para>Complex locations will perform the above steps on each pair of
      member locations in turn, and the intersection will be the set of all
      unique locations that these pair-wise intersections produce. Any
      overlapping locations on the same strand within this set will be merged
      into single, larger locations.</para>
    </section>

    <section>
      <title>Overlaps.</title>

      <para>Locations never overlap locations which are on a different remote
      sequence. However, locations on opposite strands may overlap each
      other.</para>

      <para>Circular locations of different circular lengths never overlap
      each other. Circular locations never overlap linear locations.</para>

      <para>Complex locations test each individual member in turn for overlap.
      The empty location never overlaps anything.</para>

      <para>Linear locations X and Y overlap iff X.min &lt;= Y.max and X.max
      &gt;= Y.min.</para>

      <para>Circular locations (of the same circular length) X and Y overlap
      iff X.min &lt;= Y.max-N and X.max &gt;= Y.min-N where N is some multiple
      of the circular length of either location.</para>
    </section>

    <section>
      <title>Contains.</title>

      <para>There are two types of contains operation - one tests the presence
      of a particular point coordinate, the other tests whether this location
      entirely encompasses another location. </para>

      <para>Complex locations make the test against each member in turn. The
      empty location never will never contain anything.</para>

      <section>
        <title>Point coordinates.</title>

        <para>For linear locations, a location contains a point if that point
        falls on or between the min and max of this location. If the min or
        max of this location is fuzzy, it is resolved into a single point
        first before the test is made.</para>

        <para>For circular locations, the point is defined to be contained by
        a location if the point +/- some multiple of the circular length of
        the location lies between the min and max of the location.</para>
      </section>

      <section>
        <title>Other locations.</title>

        <para>Locations never contain locations which are on a different
        strand or remote sequence.</para>

        <para>A linear location X contains another linear location Y iff X.min
        &lt;= Y.min and X.max &gt;= Y.max.</para>

        <para>A circular location X contains any other location Y iff X.min
        &lt;= Y.min-N and X.max &gt;= Y.max-N where N is some multiple of the
        circular length of the location X.</para>
      </section>
    </section>

    <section>
      <title>Obtaining the symbols for a location.</title>

      <para>The symbols for a location are obtained by calling
      <code>symbols()</code> on the location object and passing in the
      reference sequence which the location must be applied to. If the
      location contains coordinates that are outside the range of the
      reference sequence, an exception will be thrown.</para>

      <para>The location will iterate through each of its members (or just
      itself if it is a <code>SimpleRichLocation</code>) and concatenate the
      results of calling <code>symbols()</code> on each of them in turn. The
      concatenated sequence is then returned. This means that the order of the
      members is important. It will always be the same as the order in which
      the members were specified to
      <code>RichLocation.Tools.construct()</code>, if that was the way you put
      this location together.</para>

      <para>Where it comes across a remote location that refers to a sequence
      other than the one passed in for reference, the
      <code>CrossReferenceResolver</code> of that location is used to obtain
      the remote sequence. The default <code>CrossReferenceResolver</code>,
      <code>SimpleCrossReferenceResolver</code>, will return a number of
      ambiguity symbols equivalent to the length of the remote location if the
      remote sequence cannot be found. </para>

      <para>The sequences of locations on the negative strand will be reverse
      complemented before concatenation to the results. Hence it is important
      that you construct complex locations on the negative strand with the
      member locations appearing in order from 3' to 5' end of the positive
      strand if you want the <code>symbols()</code> call to return sensible
      results.</para>
    </section>
  </chapter>

  <chapter>
    <title>Features</title>

    <section>
      <title>Adding features to a <code>RichSequence</code>.</title>

      <para>The best way to create a new feature is like this:</para>

      <programlisting>Feature.Template templ = new RichFeature.Template();           // create a feature template
templ.location = ...;                                          // assign the feature template a location, type, and source
templ.typeTerm = ...;
templ.sourceTerm = ...;  
templ.annotation = new SimpleRichAnnotation();                 // assign the rest of the necessary stuff
templ.featureRelationshipSet = new TreeSet();
templ.rankedCrossRefs = new TreeSet();
RichSequence rs = ...;                                         // get a sequence from somewhere
RichFeature feat = rs.createFeature(RichFeature.Template());   // make a new feature on that sequence</programlisting>

      <para>Alternatively, you can start with a completely empty dummy feature
      and just customise the bits you need:</para>

      <programlisting>RichSequence rs = ...;                                     // get a sequence
RichFeature feat = RichFeature.Tools.makeEmptyFeature();   // make an empty feature
feat.setParent(rs):                                        // associate sequence with feature
rs.getFeatureSet().add(feat);                              // associate feature with sequence
// customise the feature here, eg. location, type, source etc.</programlisting>
    </section>

    <section>
      <title>Qualifiers as annotations.</title>

      <para>All feature qualifiers are stored as annotations. Qualifier
      annotations have a <code>ComparableTerm</code> as key, and a
      <code>String</code> as the value. Multiple qualifiers with the same term
      are allowed but only if the values are distinct. Use the rank of the
      annotation to preserve order.</para>

      <para>To go through all the qualifiers on a particular feature is quite
      straightforward:</para>

      <programlisting>RichFeature feat = ...; // get the feature from somewhere
for (Iterator i = feat.getNoteSet().iterator(); i.hasNext; ) {
    // get the next note
    Note n = (Note)i.next();
    // read it
    String key = n.getKey().getName();
    String value = n.getValue();
    int rank = n.getRank();
    // print the qualifier out in key=value (rank) format
    System.out.println(key+"="+value+" ("+rank+")"); 
}</programlisting>
    </section>

    <section>
      <title>Obtaining the symbols for a feature.</title>

      <para>The symbols for a feature are simply the result of a delegated
      call to the <code>symbols()</code> method of the feature's
      <code>Location</code> object, using the feature's parent object as the
      reference sequence for the location. See the section on locations in
      this document for details on how the symbols are obtained.</para>
    </section>
  </chapter>

  <chapter>
    <title>Relationships between features.</title>

    <section>
      <title>Relating two features.</title>

      <para>Two features can be related to each other by using a
      <code>RichFeatureRelationship</code> object to construct the
      link.</para>

      <para>Relationships have compulsory ranks. Use 0 if you don't want to
      bother with this.</para>

      <para>The following code snippet defines a new term "contains" in the
      default ontology, then creates a relationship that states that feature A
      (the parent) contains feature B (the child):</para>

      <programlisting>ComparableTerm contains = RichObjectFactory.getDefaultOntology().getOrCreateTerm("contains");
...
RichFeature parent = ...; // get feature A from somewhere 
RichFeature child = ...; // get feature B from somewhere
RichFeatureRelationship relationship = new RichFeatureRelationship(parent,child,contains,0);
parent.addFeatureRelationship(relationship); // add the relationship to the parent
...
parent.removeFeatureRelationship(relationship); // you can always take it away again later</programlisting>
    </section>

    <section>
      <title>Querying the relationship.</title>

      <para>Features are aware of all relationships in which they are the
      parent feature.</para>

      <para>The following code snippet prints out all the relationships to
      child features within a parent feature:</para>

      <programlisting>RichFeature feature = ...; // get a feature from somewhere
for (Iterator i = feature.getFeatureRelationshipSet().iterator(); i.hasNext(); ) {
     RichFeatureRelationship fr = (RichFeatureRelationship)i.next();
     RichFeature parent = fr.getObject(); // parent == feature
     RichFeature child = fr.getSubject(); 
     ComparableTerm relationship = fr.getTerm();
     // print out the relationship (eg. "A contains B");
     System.out.println(parent.getName()+" "+relationship.getName()+" "+child.getName());
}</programlisting>
    </section>
  </chapter>

  <chapter>
    <title>Annotations and Comments.</title>

    <section>
      <title>Annotations.</title>

      <para>The original BioJava allowed annotations to take the form of any
      object as the key, with any other object as the value. BioJavaX
      restricts this significantly in order to make life easier when dealing
      with databases. The new requirement, for <code>RichAnnotation</code>
      objects, is that they keys are all instances of
      <code>ComparableTerm</code>, and the values are all instances of
      <code>String</code>.</para>

      <para>Anything which is annotatable (eg. <code>BioEntry</code>,
      <code>RichFeature</code>, etc.) will implement
      <code>RichAnnotatable</code>. You can then use
      <code>getAnnotation()</code> to obtain the <code>RichAnnotation</code>
      object and start annotating with it. </para>

      <para>To obtain the <code>ComparableTerm</code> objects to use as keys,
      the simplest method is to call
      <code>RichObjectFactory.getDefaultOntology().getOrCreateTerm("myterm")</code>.</para>
    </section>

    <section>
      <title>Comments.</title>

      <para>Sequences can have free-text comments (in the form of a
      <code>String</code> instance wrapped in a <code>Comment</code> instance)
      associated with them. Each comment is ranked. Duplicate comments with
      identical text and rank will be ignored. The number of comments allowed
      is unlimited. </para>

      <para>To add a comment, call <code>addComment()</code> on the sequence
      object.</para>
    </section>

    <section>
      <title>UniProt structured comments.</title>

      <para>When parsing UniProt and UniProtXML files, comments take on a
      structured form. This is represented in text form by special formatting,
      but in order to parse this information out succesfully (particularly
      important when writing UniProtXML) a separate parser is required to
      transform the structured text into a usable object.</para>

      <para>This parser is the <code>UniProtCommentParser</code>. It has two
      main methods, <code>parseComment()</code> for converting structured text
      into an object, and <code>generate()</code> for converting the object
      back into structured text. The 'object' is actually the parser itself,
      which has a number of methods for accessing information from the parsed
      comment, or setting information to be written out next time
      <code><code>generate()</code></code> is called.</para>
    </section>
  </chapter>

  <chapter>
    <title>Namespaces.</title>

    <section>
      <title>Obtaining <code>Namespace</code> instances.</title>

      <para>All sequences in BioJavaX must belong to a namespace, by being
      associated with an instance of the <code>Namespace</code> interface.
      This is in line with BioSQL.</para>

      <para>A default namespace is provided by the
      <code>RichObjectFactory</code>:</para>

      <programlisting>// get the default namespace
Namespace defaultNS = RichObjectFactory.getDefaultNamespace(); 
...
// make a custom namespace
Namespace customNS = (Namespace)RichObjectFactory.getObject(SimpleNamespace.class, new Object[]{"myNameSpace"}); 
...
// load a namespace from BioSQL, or create it if it doesn't exist yet
Namespace biosqlNS = (Namespace)HibernateRichObjectFactory.getObject(SimpleNamespace.class, new Object[]{"myBioSQLNameSpace"});
...
// change the default namespace to "bloggs"
RichObjectFactory.setDefaultNamespaceName("bloggs");</programlisting>
    </section>
  </chapter>

  <chapter>
    <title>NCBI Taxonomy.</title>

    <section>
      <title>Traversing from child to parent.</title>

      <programlisting>NCBITaxon child = ...;  // some taxon object you want the parent of
Integer parentNCBITaxID = new Integer(child.getParentNCBITaxID());
NCBITaxon parent = (NCBITaxon)RichObjectFactory.getObject(SimpleNCBITaxon.class,new Object[]{parentNCBITaxID});</programlisting>
    </section>

    <section>
      <title>Traversing from parent to child.</title>

      <para>This cannot be done using the BioJavaX API. </para>

      <para>But, you can do it using HQL if you are reading your taxonomy
      information from a database. See the section on BioSQL and Hibernate for
      details about setting BioJavaX for use with a database. The query you
      are looking for is this:</para>

      <programlisting>NCBITaxon parent = ...;    // some taxon object you want to get the immediate children of
Query q = session.createQuery("from Taxon where parentNCBITaxID = :parentNCBITaxID");
q.setInteger("parentNCBITaxID",parent.getNCBITaxID());
List children = q.list();  // children will now contain all the child taxon objects</programlisting>
    </section>

    <section>
      <title>Finding taxons by name.</title>

      <para>This also cannot be done using the BioJavaX API.</para>

      <para>Again, you can do it using HQL if you are reading your taxonomy
      information from a database. The query you are looking for is
      this:</para>

      <programlisting>Query q = session.createQuery("from Taxon as taxon join taxon.nameSet as taxonName "+
                                 "where taxonName.nameClass=:nameClass and taxonName.name=:name");
q.setString("nameClass",NCBITaxon.SCIENTIFIC);
q.setString("name","Homo sapiens");
List taxons = q.list();  // taxons will now contain all matching taxon objects</programlisting>
    </section>
  </chapter>

  <chapter>
    <title>BioSQL and Hibernate.</title>

    <section>
      <title>Introduction to Hibernate.</title>

      <para>BioJavaX uses Hibernate to manage persistence of BioJavaX objects
      to/from a database. </para>

      <para>Hibernate works by parsing a set of mapping files that tell it how
      to translate between objects/fields and tables/columns. It tracks
      changes, writes and executes all the SQL required, and does its best to
      keep everything consistent and efficient so that your application never
      needs to talk directly to the database. It also enforces all
      primary/foreign-key relations between objects.</para>

      <para>Hibernate revolves around the use of JavaBeans. A single JavaBean
      usually represents a single table. This is the case in BioJavaX. Each
      column of the table is represented by a field with a standard
      getter/setter pair of methods within the bean. Hibernate uses these
      get/set methods to load and save the values to and from the database.
      Foreign-keys are represented by defining the field as an instance of the
      bean representing the foreign table. One-to-many relationships are made
      by defining the field as an instance of a <code>Collection</code>, where
      each member of the collection is the bean representing the foreign
      table.</para>

      <para>BioJavaX contains virtually no query code, and provides no API for
      querying the database. This is because the API <emphasis>is</emphasis>
      the object model. You do not need to have anything more than a Hibernate
      session to be able to read and write BioJavaX objects directly to the
      database.</para>

      <para>Mapping files are provided only for BioSQL, as this is the
      database schema that BioJavaX was designed to imitate, but there is no
      reason why mapping files could not be created for other database
      schemas. Please feel free to contribute them if you do so.</para>

      <para>The BioSQL mapping files use lazy-loading extensively. This means
      that data usually will not get loaded until you try to access it using
      the appropriate getter/setter method of the object. You can change this
      behaviour by editing the mapping files.</para>

      <para>Queries are constructed not using SQL but using the Hibernate
      Query Language, or HQL. You can find out more about HQL and the
      Hibernate project at their website: <ulink
      url="http://www.hibernate.org/">http://www.hibernate.org/</ulink></para>
    </section>

    <section>
      <title>Hibernate object-relational mappings.</title>

      <para>The following table describes which object in BioJavaX ends up in
      which table in BioSQL. The first column is the name of the BioSQL table,
      the second is the mapping name to be used in HQL to query the table, and
      the third column is the class of object you will get when the query
      returns results:</para>

      <table>
        <title>Hibernate object-relational mappings.</title>

        <tgroup cols="3">
          <tbody>
            <row>
              <entry>biodatabase</entry>

              <entry>Namespace</entry>

              <entry><code>SimpleNamespace</code></entry>
            </row>

            <row>
              <entry>taxon</entry>

              <entry>Taxon</entry>

              <entry><code>SimpleNCBITaxon</code></entry>
            </row>

            <row>
              <entry>bioentry</entry>

              <entry>BioEntry</entry>

              <entry><code>SimpleBioEntry</code></entry>
            </row>

            <row>
              <entry>taxon_name</entry>

              <entry>(use properties of NCBITaxon)</entry>

              <entry><code>SimpleNCBITaxonName</code></entry>
            </row>

            <row>
              <entry>biosequence</entry>

              <entry>Sequence</entry>

              <entry><code>SimpleRichSequence</code></entry>
            </row>

            <row>
              <entry>bioentry_relationship</entry>

              <entry>BioEntryRelationship</entry>

              <entry><code>SimpleBioEntryRelationship</code></entry>
            </row>

            <row>
              <entry>comment</entry>

              <entry>Comment</entry>

              <entry><code>SimpleComment</code></entry>
            </row>

            <row>
              <entry>dbxref</entry>

              <entry>CrossRef</entry>

              <entry><code>SimpleCrossRef</code></entry>
            </row>

            <row>
              <entry>bioentry_dbxref</entry>

              <entry>(use properties of BioEntry)</entry>

              <entry><code>SimpleRankedCrossRef</code></entry>
            </row>

            <row>
              <entry>reference</entry>

              <entry>DocRef</entry>

              <entry><code>SimpleDocRef</code></entry>
            </row>

            <row>
              <entry>bioentry_reference</entry>

              <entry>(use properties of BioEntry)</entry>

              <entry><code>SimpleRankedDocRef</code></entry>
            </row>

            <row>
              <entry>dbxref_qualifer_value</entry>

              <entry>(use properties of CrossRef)</entry>

              <entry><code>SimpleNote</code></entry>
            </row>

            <row>
              <entry>bioentry_qualifier_value</entry>

              <entry>(use properties of BioEntry)</entry>

              <entry><code>SimpleNote</code></entry>
            </row>

            <row>
              <entry>ontology</entry>

              <entry>Ontology</entry>

              <entry><code>ComparableOntology</code></entry>
            </row>

            <row>
              <entry>term</entry>

              <entry>Term</entry>

              <entry><code>ComparableTerm</code></entry>
            </row>

            <row>
              <entry>term_relationship</entry>

              <entry>Triple</entry>

              <entry><code>ComparableTriple</code></entry>
            </row>

            <row>
              <entry>term_synonym</entry>

              <entry>(use properties of Term)</entry>

              <entry><code>String</code></entry>
            </row>

            <row>
              <entry>term_dbxref</entry>

              <entry>(use properties of Term)</entry>

              <entry><code>SimpleRankedCrossRef</code></entry>
            </row>

            <row>
              <entry>seqfeature</entry>

              <entry>Feature</entry>

              <entry><code>SimpleRichFeature</code></entry>
            </row>

            <row>
              <entry>seqfeature_qualifier_value</entry>

              <entry>(use properties of Feature)</entry>

              <entry><code>SimpleNote</code></entry>
            </row>

            <row>
              <entry>seqfeature_dbxref</entry>

              <entry>(use properties of Feature)</entry>

              <entry><code>SimpleRankedCrossRef</code></entry>
            </row>

            <row>
              <entry>seqfeature_relationship</entry>

              <entry>FeatureRelationship</entry>

              <entry><code>SimpleRichFeatureRelationship</code></entry>
            </row>

            <row>
              <entry>location</entry>

              <entry>Location</entry>

              <entry><code>SimpleRichLocation</code>,
              <code>CompoundRichLocation</code>, or
              <code>EmptyRichLocation</code></entry>
            </row>

            <row>
              <entry>location_qualifier_value</entry>

              <entry>(use properties of Location)</entry>

              <entry><code>SimpleNote</code></entry>
            </row>

            <row>
              <entry>seqfeature_path</entry>

              <entry>-</entry>

              <entry>-</entry>
            </row>

            <row>
              <entry>bioentry_path</entry>

              <entry>-</entry>

              <entry>-</entry>
            </row>

            <row>
              <entry>term_path</entry>

              <entry>-</entry>

              <entry>-</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>Configuring your application to use Hibernate and BioSQL.</title>

      <para>To use Hibernate with your application, you need to do five
      things:</para>

      <orderedlist>
        <listitem>
          <para>Install Hibernate.</para>
        </listitem>

        <listitem>
          <para>Copy and configure the Hibernate mapping files for your
          database. </para>
        </listitem>

        <listitem>
          <para>Create a Hibernate session and connect it to BioJavaX.</para>
        </listitem>

        <listitem>
          <para>Open a transaction.</para>
        </listitem>

        <listitem>
          <para>Read/write objects from the database.</para>
        </listitem>

        <listitem>
          <para>End the transaction.</para>
        </listitem>

        <listitem>
          <para>Close the Hibernate session.</para>
        </listitem>
      </orderedlist>

      <section>
        <title>Installing Hibernate.</title>

        <para>Hibernate consists of a number of JAR files, downloadable from
        their website at <ulink
        url="http://www.hibernate.org/">http://www.hibernate.org/</ulink>. You
        should add these JAR files to your classpath. You will also need to
        download the JAR file for your database's JDBC driver, and add that to
        your classpath too.</para>

        <para><remark>Note for Oracle users:</remark> the mapping files
        supplied for Oracle BioSQL are designed to work only with Oracle 9i or
        better database and Oracle 9i or better JDBC drivers.</para>
      </section>

      <section>
        <title>Copying and configuring the mapping files.</title>

        <para>BioJavaX is supplied with four sets of mapping files, all of
        which define the mapping between BioJavaX objects and a BioSQL
        database. The four sets are for Oracle, PostGreSQL, MySQL, and
        HSQLDB.</para>

        <para>You will find the mapping files in the source package
        <code>org.biojavax.bio.seq.db.biosql.*</code>. Choose the set you want
        and copy them to one of the following places:</para>

        <itemizedlist>
          <listitem>
            <para>The root of your <code>.jar</code> file if your application
            is compiled as a JAR.</para>
          </listitem>

          <listitem>
            <para>The current working directory of your application.</para>
          </listitem>
        </itemizedlist>

        <para>To configure Hibernate, you must edit the copy you made of the
        <code>hibernate.cfg.xml</code> file. Near the top is a section that
        looks like this:</para>

        <programlisting>&lt;property name="connection.datasource"&gt;java:comp/env/jdbc/YOUR_JNDI_DATASOURCE_GOES_HERE&lt;/property&gt;
        
&lt;!-- OR... (for testing only)...
&lt;property name="connection.driver_class"&gt;oracle.jdbc.driver.OracleDriver&lt;/property&gt;
&lt;property name="connection.url"&gt;jdbc:oracle:thin:@MYSERVER:MYPORT:MYSID&lt;/property&gt;
&lt;property name="connection.username"&gt;MYUSER&lt;/property&gt;
&lt;property name="connection.password"&gt;MYPASSWORD&lt;/property&gt;
&lt;property name="connection.pool_size"&gt;20&lt;/property&gt;
--&gt;</programlisting>

        <para>The exact details will vary according to which database you are
        using.</para>

        <para>You will see that the default way of using Hibernate is through
        a JNDI datasource, usually supplied by a servlet container such as
        Tomcat. In this case, you should modify the
        <code>connection.datasource</code> parameter to reflect the name of
        your JNDI datasource.</para>

        <para>If you are not using JNDI, then comment that line out and
        uncomment the section marked 'testing only'. This section allows you
        to configure Hibernate to use a JDBC connection to talk to your
        database. Please read more about this at <ulink
        url="http://www.hibernate.org/">http://www.hibernate.org/</ulink> if
        you intend to use JDBC directly, as there are several caveats
        regarding connection pooling that must be taken into consideration.
        The configuration shown above is recommended only for development, and
        is not suitable either for production code or for performance
        testing.</para>
      </section>

      <section>
        <title>Opening and closing sessions.</title>

        <para>Hibernate deals in sessions, which must be opened before a
        database can be used, and closed again at the end in order to bring
        the database back into a consistent state. Hibernate will attempt to
        clean-up automatically if you forget to close the session, but it is
        better to be safe than sorry and close it explicitly.</para>

        <para>BioJavaX <emphasis>must</emphasis> be told about the session in
        order to be able to use it to manage database singleton objects such
        as namespaces or taxon definitions. If you fail to connect the session
        to BioJavaX, you will almost certainly end up with 'unique constraint
        violation' exceptions being thrown left, right and centre. So be
        careful!</para>

        <para>You <emphasis>must</emphasis> connect the session to BioJavaX
        <emphasis>before</emphasis> doing any operations with it at all. It
        should usually be the first or very nearly the first line in your
        code.</para>

        <para>To open a Hibernate session and connect it to BioJavaX:</para>

        <programlisting>SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory();  // load Hibernate config
Session session = sessionFactory.openSession();                                         // open the session
RichObjectFactory.setRichObjectBuilder(new HibernateRichObjectBuilder(session));        // connect it to BioJavaX</programlisting>

        <para>To close the Hibernate session:</para>

        <programlisting>session.close();</programlisting>

        <para>Note that the line that loads the Hibernate configuration only
        needs to be done once, regardless of how many sessions you open, as
        long as you keep a reference to your <code>sessionFactory</code>
        somewhere handy.</para>
      </section>

      <section>
        <title>Transactions.</title>

        <para>If you are going to be writing objects to the database, you must
        use transactions. If you are only reading from the database, then
        transactions are recommended but not compulsory. It's probably safest
        to use them anyway then you needn't worry about it.</para>

        <para>A transaction defines a unit of work. BioJavaX never commits or
        rolls back anything, so this is left entirely up to the user to decide
        when to do so. Transactions are opened with a single line of code, and
        rolled back or committed with another single line of code. You'd
        usually use them in a construct such as this:</para>

        <programlisting>Transaction tx = session.beginTransaction();  // begin the transaction
try {
    // do some stuff with BioJavaX objects here.
    ...
    tx.commit();          // commit the transaction if all went well
} catch (Exception e) {
    tx.rollback();        // roll back the transaction if something went wrong
    e.printStackTrace();  // tell the user what went wrong
}</programlisting>

        <para>Once a transaction object has been committed or rolled back you
        cannot use it any more and must open a new one.</para>
      </section>

      <section>
        <title>Complete example.</title>

        <para>This example iterates through every namespace it can find in the
        database, and prints the names out. It also prints out the names of
        all the sequences in each namespace, whether they be
        <code>BioEntry</code> or <code>RichSequence</code> instances. If it
        finds any sequences where the name is equal to 'bloggs', it changes
        their version to 99. It then commits any changes it has made and
        exits.</para>

        <para>This example shows just how easy it is to read and write to the
        database. No SQL required!</para>

        <programlisting>SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory();  
Session session = sessionFactory.openSession();                                                             
RichObjectFactory.setRichObjectBuilder(new HibernateRichObjectBuilder(session)); 

Transaction tx = session.beginTransaction();
try {

    // print out all the namespaces in the database

    Query q = session.createQuery("from Namespace");
    List namespaces = q.list();               // retrieve all the namespaces from the db
    for (Iterator i = namespaces.iterator(); i.hasNext(); ) {
        Namespace ns = (Namespace)i.next();
        System.out.println(ns.getName());     // print out the name of the namespace

        // print out all the sequences in the namespace

        for (Iterator j = ns.getMembers().iterator(); j.hasNext(); ) {
            BioEntry be = (BioEntry)j.next();        // RichSequences are BioEntrys too
            System.out.println("   "+be.getName());  // print out the name of the sequence

            // if the sequence is called bloggs, change its version to 99

            if (be.getName().equals("bloggs")) {
                be.setVersion(99);
            }
        }

    }

    // commit and tidy up
    tx.commit();         
    System.out.println("Changes committed.");

    // all sequences called bloggs now have a version of 99 in the database

} catch (Exception e) {
    tx.rollback();       
    System.out.println("Changes rolled back.");
    e.printStackTrace(); 
}

session.close();</programlisting>
      </section>
    </section>

    <section>
      <title>Flattened locations.</title>

      <para>BioSQL does not have a concept of hierarchical locations. It
      allows multiple locations per feature, but it does not allow locations
      to have sub-locations or references to other locations. This means that
      the hierarchical location model allowed in BioJavaX must be flattened
      out into a one-level collection of simple locations before it can be
      persisted. </para>

      <para>This flattening is done by
      <code>RichLocation.Tools.flatten()</code>. It only takes place at the
      point the user tries to save the location to the database, at which
      point not only does the database copy get flattened, but the in-memory
      one does too. The flattened location will logically represent the exact
      same area as the hierarchical original, but it will be constructed
      differently. The symbols returned by both the original and the flattened
      locations should be identical, as would the results of any union,
      intersection, contains, or overlaps operation.</para>

      <para>The circularity of locations will be lost altogether when
      persisted to BioSQL.</para>
    </section>

    <section>
      <title>Persisting objects.</title>

      <para>Any object created by using methods from RichObjectFactory will
      automatically attach itself to the database and persist when the
      transaction is committed.</para>

      <para>Any object you create directly yourself must be explicitly
      attached to the database using the appropriate Hibernate mapping name
      from the table earlier in this chapter. If the object you persist has
      properties that are other mappable objects, they will be persisted too
      in a cascading fashion.</para>

      <para>For example, to persist a RichSequence object that you have just
      created, do this (inside a transaction):</para>

      <programlisting>RichSequence rs = ...;                    // some sequence you've made
session.saveOrUpdate("RichSequence",rs);  // persist the sequence</programlisting>

      <para>Nothing will actually get saved to the database until you commit
      the transaction. If you rollback the transaction or exit without
      committing first, all changes will be lost.</para>
    </section>

    <section>
      <title>Loading objects.</title>

      <para>Loading objects involves having to learn some HQL. The simplest
      cases are very easy, however it can get quite complex quite quickly. The
      thing you have to remember is that you are querying objects,
      <emphasis>not</emphasis> the database. As such, your results may include
      objects that have been persisted but not committed.</para>

      <para>The simplest HQL query is the equivalent of a SQL <code>select *
      from sometable</code>. This is how you use it to select all namespaces
      from the database:</para>

      <programlisting>Query q = session.createQuery("from Namespace");
List namespaces = q.list();  // namespaces now contains all the Namespace objects in the database</programlisting>

      <para>To set constraints your query should refer to object parameters,
      not table columns. The following query selects the namespace that is
      called 'bloggs':</para>

      <programlisting>Query q = session.createQuery("from Namespace where name=:name");
q.setString("name","bloggs");
List namespaces = q.list();                  // should only contain one Namespace object. Empty if none found.
Namespace ns = (Namespace)q.uniqueObject();  // alternative notation for queries with single-row results</programlisting>

      <para>You don't have to worry about foreign keys, and can just join
      objects directly without specifying which field to use. This query
      returns all RichSequence objects that have a comment that contains the
      word "rubbish" with a rank of 0:</para>

      <programlisting>Query q = session.createQuery("select rs from RichSequence as rs join Comment as c where c.comment like :comment and rank=:rank");
q.setString("comment","%rubbish%");  // % symbol means match any string
q.setInteger("rank",0);
List sequences = q.list();           // a list of all matching RichSequence objects.</programlisting>

      <para>This query demonstrates the (unique) case of <code>BioEntry</code>
      and <code>RichSequence</code> being represented as a single Hibernate
      mapping, hence no join required to access fields from either
      table:</para>

      <programlisting>Query q = session.createQuery("from RichSequence where length&gt;:length and name=:name");
q.setInteger("length",200);
q.setString("name","joe");
List sequences = q.list();</programlisting>

      <para>This query demonstrates how you can use other BioJavaX objects in
      the where clause without having to do any work at all. It returns all
      sequences that belong in a particular namespace:</para>

      <programlisting>Namespace ns = ...;   // get a namespace from somewhere, eg. RichObjectFactory.getDefaultNamespace()
Query q = session.createQuery("from RichSequence where namespace=:namespace");
q.setParameter("namespace",ns);   // plug the namespace object right in!
List sequences = q.list();</programlisting>

      <para>There's no way this tutorial could ever hope to teach you all
      about HQL! The best thing to do is go to the Hibernate website and read
      up on it there: <ulink
      url="http://www.hibernate.org/">http://www.hibernate.org/</ulink>.</para>
    </section>

    <section>
      <title>Loading individual values from objects.</title>

      <para>You might not always want to retrieve lists of objects from the
      database. This query retrieves the names of sequences:</para>

      <programlisting>Query q = session.createQuery("select name from RichSequence");
List names = q.list();  // list will contain String instances containing the names</programlisting>

      <para>This one returns all the lengths of sequences, which are integers.
      Note the use of <code>sequenceLength</code>, which is the object
      parameter, and not <code>length</code> which is the database table
      column name:</para>

      <programlisting>Query q = session.createQuery("select sequenceLength from RichSequence");
List lengths = q.list();  // list will contain Integer instances containing the lengths</programlisting>
    </section>

    <section>
      <title>Deleting objects.</title>

      <para>Objects can be removed from the database by calling:</para>

      <programlisting>session.delete(obj); // where obj is some persistent object</programlisting>

      <para>Only when the transaction is committed will they actually be
      deleted. If the transaction is rolled back, the objects will come back
      to life.</para>
    </section>

    <section>
      <title>Auto-generating the BioSQL schema.</title>

      <para>One nice side-effect of the Hibernate mappings is that they are
      able to completely regenerate the database schema required to support
      their functionality. Whilst this does not usually create a schema that
      is identical to the one you started with, it will function in the same
      way and produce the same results, and can be handy for development or
      testing purposes only. </para>

      <para>It is not recommended that the generated scripts be used for
      production databases without some manual checking and fine-tuning, and
      it is most certainly not recommended to use the generated scripts in
      place of any 'official' schema generation scripts such as those that are
      provided by the BioSQL project. </para>

      <para>Here is the code to generate the DDL from the Hibernate mappings.
      It will be printed to standard output (usually the screen)</para>

      <programlisting>Configuration cfg = new Configuration().configure();
new SchemaExport(cfg).create(true, false);</programlisting>
    </section>

    <section>
      <title>Reading/writing objects as XML.</title>

      <para>There is a bug in Hibernate which prevents this function from
      working 100% correctly (bug details <ulink
      url="http://opensource2.atlassian.com/projects/hibernate/browse/HHH-796">here</ulink>),
      however the code is supplied as an example for when the bug is fixed.
      </para>

      <para>The snippet below will query the database for all DocRef objects,
      then output an XML representation of them to standard out:</para>

      <programlisting>Document doc = DocumentHelper.createDocument();        
Element root = doc.addElement("myRootNode");    // some arbitrary name for the XML root node

Session dom4jSession = session.getSession(EntityMode.DOM4J);
       
Query q = dom4jSession.createQuery("from DocRef");
List results = q.list();
for (Iterator i = results.iterator(); i.hasNext(); ) {
    Element rs = (Element)i.next();
    root.add(rs)
}

session.close();
        
// Pretty print the document to System.out
OutputFormat format = OutputFormat.createPrettyPrint();
XMLWriter writer = new XMLWriter(System.out, format);
writer.write(doc);</programlisting>

      <para>Reading them back and saving them to the database is
      similar:</para>

      <programlisting>Document doc = ...;                          // open an XML document with some kind of org.dom4j.io.SAXReader
List results = doc.selectNodes("//docref");  // use the node-name from the class tag of DocRef.hbm.xml mapping file
        
Transaction tx = session.beginTransaction();
Session dom4jSession = session.getSession(EntityMode.DOM4J);
       
for (Iterator i = results.iterator(); i.hasNext(); ) {
    Object rs = (Object)i.next();
    dom4jSession.saveOrUpdate("DocRef",rs);
}
        
tx.commit();
session.close();</programlisting>
    </section>
  </chapter>

  <chapter>
    <title>Genetic Algorithms.</title>

    <section>
      <title>Overview.</title>

      <para>With the introduction of the <code>org.biojavax.ga</code> package
      it is now possible to generate Genetic Algorithms using BioJava. </para>

      <para>Genetic Algorithms are a class of simulation, optimization or
      problem solving algorithms that attempt to evolve a solution to a
      problem. The solution being evolved is encoded as a 'chromosome' which
      is typically a binary string although other encodings are possible. At
      each generation (iteration) a population of chromosomes is available.
      Like real chromsomes they mutate and recombine with some frequency at
      each generation. Critically, after each round of potential mutation and
      recombination the chromosomes that encode the best solution are favoured
      for replication. Thus, there is a trend towards increasingly good
      solutions in the population.</para>

      <para>The functions and stopping criteria are all Java interfaces so
      custom implementations are possible. The only requirement for the
      <code>GeneticAlgorithm</code> is that is has a <code>Population</code>,
      a <code>MutationFunction</code>, a <code>CrossOverFunction</code>, a
      <code>FitnessFunction</code>, a <code>SelectionFunction</code> and a
      <code>GAStoppingCriteria</code>. The actual implementations used are
      interchangeable. Further, the 'chromosome(s)' of the
      <code>Organism</code>s in a <code>Population</code> are just BioJava
      <code>SymbolList</code>s and any <code>Alphabet</code> could be used to
      encode a solution.</para>
    </section>

    <section>
      <title>Example listing.</title>

      <para>The example below demonstrates a very simple genetic algorithm
      constructed using the GA framework. The framework is designed to be very
      flexible and uses an interchangeable parts philosophy. </para>

      <para>The core interface is the <code>GeneticAlgorithm</code> with its
      default implementation, <code>SimpleGeneticAlgorithm</code>. The
      <code>GeneticAlgorithm</code> takes any <code>Population</code> of
      <code>Organism</code>s and iterates through the generations. At each
      step a <code>MutationFunction</code> and a
      <code>CrossOverFunction</code> are responsible for introducing
      variation. </para>

      <para>A <code>FitnessFunction</code> is responsible for determining the
      fitness of each <code>Organism</code> in the context of it's parent
      <code>Population</code>. Because fitness can be calculated in the
      context of a <code>Population</code> it is possible to model competition
      within a <code>Population</code>. The <code>Organism</code>s to be
      selected for replication are nominated by the
      <code>SelectionFunction</code> usually on the basis of their fitness.
      </para>

      <para>The <code>GeneticAlgorithm</code> will stop iterating when the
      <code>GAStoppingCriteria</code> tells it to. This may be when a suitable
      solution has been reached or after a finite number of
      generations.</para>

      <programlisting>public class GADemo{
  public static void main(String[] args) throws Exception{
    //print the header
    System.out.println("gen,average_fitness,best_fitness");

    //a uniform Distribution over the binary Alphabet
    Distribution bin_dist = new UniformDistribution(GATools.getBinaryAlphabet());

    //initialize the population
    Population pop = new SimplePopulation("demo population");

    //add 100 organisms
    for(int i = 0; i &lt; 100; i++){
      Organism o = new SimpleOrganism("organism"+i);

      //make 1 random chromosome for each organism
      SymbolList[] ch = new SymbolList[1];
      //the symbols are randomly sampled from bin_dist
      ch[0] = new SimpleSymbolList(DistributionTools.generateSequence(
          "", bin_dist, 100));

      //set the organisms chromosome to be ch
      o.setChromosomes(ch);

      //add to organism to the population pop
      pop.addOrganism(o);
    }


    //created a SelectionFunction
    SelectionFunction sf = new ProportionalSelection();
    //set its FitnessFunction
    sf.setFitnessFunction(new DemoFitness());

    //create a new CrossOverFunction
    CrossOverFunction cf = new SimpleCrossOverFunction();
    //set the max number of cross overs per chromosome
    cf.setMaxCrossOvers(1);
    //set a uniform cross over probability of 0.01
    cf.setCrossOverProbs(new double[]{0.01});

    //create a new MutationFunction
    MutationFunction mf = new SimpleMutationFunction();
    //set a uniform MutationProbability of 0.0001
    mf.setMutationProbs(new double[]{0.0001});
    //set the mutation spectrum of the function to be a standard
    //mutation distribution over the binary Alphabet
    mf.setMutationSpectrum(
        GATools.standardMutationDistribution(GATools.getBinaryAlphabet()));

    //make a GeneticAlgorithm with the above functions
    GeneticAlgorithm genAlg = new SimpleGeneticAlgorithm(pop, mf, cf, sf);
    //run the Algorithm until the criteria of DemoStopping are met
    genAlg.run(new DemoStopping());
  }

  /**
   * Basic implementation of GAStopping Criteria
   *
   */
  static class DemoStopping implements GAStoppingCriteria{

    /**
     * Determines when to stop the Algorithm
     */
    public boolean stop (GeneticAlgorithm genAlg){
      System.out.print(genAlg.getGeneration()+",");
      Population pop = genAlg.getPopulation();
      double totalFit = 0.0;

      FitnessFunction ff = genAlg.getSelectionFunction().getFitnessFunction();

      double fit = 0.0;
      double bestFitness = 0.0;

      for (Iterator it = pop.organisms(); it.hasNext(); ) {
        Organism o = (Organism)it.next();
        fit = ff.fitness(o, pop, genAlg);
        bestFitness = Math.max(fit, bestFitness);
        totalFit += fit;
      }

      //print the average fitness
      System.out.print((totalFit/ (double) pop.size())+",");
      //print the best fitness
      System.out.println(bestFitness);

      //fitness is 75.0 so stop the algorithm
      if(bestFitness &gt;= 75.0){
        System.out.println("Organism found with Fitness of 75%");
        return true;
      }

      //no organism is fit enough, continue the algorithm
      return false;
    }
  }

  /**
   * A fitness function bases on the most "one" rich chromosome in the organism.
   *
   */
  static class DemoFitness implements FitnessFunction{
    public double fitness(Organism o, Population p, GeneticAlgorithm genAlg){
      double bestfit = 0.0;

      for (int i = 0; i &lt; o.getChromosomes().length; i++) {
        SymbolList csome = o.getChromosomes()[i];
        double fit = 0.0;
        for(int j = 1; j &lt;= csome.length(); j++){
          if(csome.symbolAt(j) == GATools.one())
            fit++;
        }
        bestfit = Math.max(fit, bestfit);
      }

      return bestfit;
    }
  }
}</programlisting>
    </section>
  </chapter>
</book>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">
<book>
  <title>BioJavaX</title>

  <bookinfo>
    <date>27th October 2005</date>

    <author>
      <surname>Richard Holland</surname>
    </author>
  </bookinfo>

  <chapter>
    <title>BioJavaX is not BioJava 2 is not BioJavaX.</title>

    <para>BioJavaX is an extension to the existing BioJava project. Anything
    written with BioJava will work with BioJavaX, and vice versa. </para>

    <para><code>org.biojavax</code> is to <code>org.biojava</code> as
    <code>javax</code> is to <code>java</code>.</para>

    <para>The BioJava2 project is a completely new project which intends to
    rewrite everything in BioJava from scratch, based around a new set of
    object designs and concepts. It is entirely incompatible with the existing
    BioJava project.</para>

    <para>Therefore BioJavaX is <emphasis>not</emphasis> BioJava 2, and has
    nothing to do with it. Please don't get them confused!</para>
  </chapter>

  <chapter>
    <title>What didn't change?</title>

    <section>
      <title>Existing interfaces.</title>

      <para>Backwards-compatibility is always an issue when a major new
      version of a piece of software is released.</para>

      <para>BioJavaX addresses this by keeping all the new classes and
      interfaces tucked away inside their own special package,
      <code>org.biojavax</code>. None of the existing interfaces were modified
      in any way, so any code which depends on them will not see any
      difference.</para>

      <para>Apart from ongoing bugfixes, the way in which the existing classes
      work also has not changed.</para>

      <para>The new interfaces introduced in BioJavaX extend those present in
      the existing BioJava packages. This allows new BioJavaX-derived objects
      to be passed to legacy code and still be understood.</para>
    </section>

    <section>
      <title>Change listeners.</title>

      <para>BioJava's change listener model is intact and unchanged. The new
      BioJavaX classes define a set of extra change types which they fire in
      addition to the ones generated by existing BioJava classes. </para>

      <para>This means that existing change listeners can be attached to
      BioJavaX-derived objects and still receive all the information they
      would normally receive.</para>
    </section>

    <section>
      <title>Event-based file parsing.</title>

      <para>BioJavaX still uses event-based file parsing to read and write
      files, in exactly the same way as the old BioJava classes did. </para>

      <para>However, you cannot use existing event listeners with the new
      BioJavaX file parsers. You must alter the listeners to extend the new
      <code>org.biojavax.bio.seq.io.RichSeqIOListener</code> interface
      instead.</para>
    </section>
  </chapter>

  <chapter>
    <title>What did change?</title>

    <section>
      <title>Rich interfaces.</title>

      <para>BioJavaX defines a new set of interfaces for working with sequence
      objects. These interfaces are closely modelled on the BioSQL 1.0
      schema.</para>

      <para>The new interfaces extend existing interfaces wherever possible,
      in order to allow backwards-compatibility with legacy code. These
      interfaces are known as rich interfaces, as they could be said to be
      'enriched' versions of the interfaces that they extend.</para>

      <para>Instances of implementing classes are known as rich objects, which
      legacy instances known as plain ones. </para>

      <para>Here is a list of the new rich interfaces:</para>

      <itemizedlist>
        <listitem>
          <para><code>ComparableOntology</code> (extends
          <code>Ontology</code>)</para>
        </listitem>

        <listitem>
          <para><code>ComparableTerm</code> (extends <code>Term</code>)</para>
        </listitem>

        <listitem>
          <para><code>ComparableTriple</code> (extends
          <code>Triple</code>)</para>
        </listitem>

        <listitem>
          <para><code>RichSequenceIterator</code> (extends
          <code>SequenceIterator</code>)</para>
        </listitem>

        <listitem>
          <para><code>RichSequence</code> (extends
          <code>Sequence</code>)</para>
        </listitem>

        <listitem>
          <para><code>RichLocation</code> (extends
          <code>Location</code>)</para>
        </listitem>

        <listitem>
          <para><code>RichFeature</code> (extends
          <code>StrandedFeature</code>)</para>
        </listitem>

        <listitem>
          <para><code>RichFeatureHolder</code> (extends
          <code>FeatureHolder</code>)</para>
        </listitem>

        <listitem>
          <para><code>RichAnnotatable</code> (extends
          <code>Annotatable</code>)</para>
        </listitem>

        <listitem>
          <para><code>RichAnnotation</code> (extends
          <code>Annotation</code>)</para>
        </listitem>
      </itemizedlist>

      <para>Wherever possible in BioJavaX, conversions are attempted if a
      method expecting a rich object receives a plain one. You can perform
      these conversions yourself by using the <code>Tools</code> sub-class of
      the appropriate rich interface, for example to convert an old
      <code>Sequence</code> object into a new <code>RichSequence</code>
      object, you can do this:</para>

      <programlisting>Sequence s = ...; // get an old Sequence object from somewhere
RichSequence rs = RichSequence.Tools.enrich(s);</programlisting>

      <para>The conversion process does its best, but it is not perfect. Much
      of the way information is stored in the new BioJavaX object model is
      fundamentally incompatible with the old object model. So its always best
      to deal with <code>RichSequence</code> objects from the word go and try
      to avoid instantiating older <code>Sequence</code> objects as far as
      possible.</para>

      <para>Other new interfaces define new concepts, or replace old
      interfaces entirely due to a fundamental clash in the way they see the
      world. Here is a list:</para>

      <itemizedlist>
        <listitem>
          <para><code>NCBITaxon</code></para>
        </listitem>

        <listitem>
          <para><code>BioEntry</code></para>
        </listitem>

        <listitem>
          <para><code>RichObjectBuilder</code></para>
        </listitem>

        <listitem>
          <para><code>Comment</code></para>
        </listitem>

        <listitem>
          <para><code>CrossRef</code></para>
        </listitem>

        <listitem>
          <para><code>CrossReferenceResolver</code></para>
        </listitem>

        <listitem>
          <para><code>DocRef</code></para>
        </listitem>

        <listitem>
          <para><code>DocRefAuthor</code></para>
        </listitem>

        <listitem>
          <para><code>Namespace</code></para>
        </listitem>

        <listitem>
          <para><code>Note</code></para>
        </listitem>

        <listitem>
          <para><code>RankedCrossRef</code></para>
        </listitem>

        <listitem>
          <para><code>RankedCrossRefable</code></para>
        </listitem>

        <listitem>
          <para><code>RankedDocRef</code></para>
        </listitem>

        <listitem>
          <para><code>BioEntryRelationship</code></para>
        </listitem>

        <listitem>
          <para><code>Position</code></para>
        </listitem>

        <listitem>
          <para><code>PositionResolver</code></para>
        </listitem>

        <listitem>
          <para><code>RichFeatureRelationship</code></para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>BioSQL persistence with Hibernate.</title>

      <para>BioJavaX introduces a whole new way of working with BioSQL
      databases.</para>

      <para>Instead of attempting to re-invent the wheel with yet another new
      object-relational mapping system, BioJavaX uses the services of
      Hibernate to do all the dirty work for it. In fact, there is not a
      single SQL statement anywhere in the BioJavaX code.</para>

      <para>The use of Hibernate allows users to have as much or as little
      control as they like over transactions and query optimisation. The
      Hibernate query language, HQL, is simple to learn and easy to
      use.</para>

      <para>You can find out more about Hibernate project at their website:
      <ulink url="http://www.hibernate.org/">http://www.hibernate.org/</ulink>
      </para>
    </section>

    <section>
      <title>Better file parsers.</title>

      <para>The old BioJava file parsers worked in that they loaded all
      information into memory, but they didn't do much at attempting to
      understand the contents of the files, and they often failed miserably
      when trying to convert between formats.</para>

      <para>The new parsers supplied with BioJavaX put a lot of effort into
      trying to fit data from the myriad of file formats out there into a form
      representable by BioSQL, and hence by the new BioJavaX object model. Of
      course this isn't always possible, but it does a much better job than
      the old ones.</para>

      <para>By parsing data into a fixed object model instead of storing
      everything as annotations (as was the case, for instance, with the old
      SwissProt parsers), conversion between file formats becomes much
      easier.</para>

      <para>The new file parsers also allow you to skip uninteresting parts of
      the file altogether, greatly speeding up simple tasks such as counting
      the number of sequences in a file.</para>
    </section>

    <section>
      <title>NCBI Taxonomy loader.</title>

      <para>A parser is provided for loading the NCBI Taxonomy database into a
      set of BioJavaX <code>NCBITaxon</code> objects. This parser reads the
      <filename>node.dmp</filename> and <filename>names.dmp</filename> files
      supplied by NCBI and constructs the appropriate hierarchy of objects. If
      you are using BioSQL, it can persist this hierarchy to the database as
      it goes.</para>
    </section>

    <section>
      <title>Namespaces.</title>

      <para>All sequences in BioJavaX must belong to a namespace.</para>
    </section>

    <section>
      <title>Singletons.</title>

      <para>As you may have noticed from the namespace example code above,
      BioJavaX tries to use singletons as far as possible. This is:</para>

      <itemizedlist>
        <listitem>
          <para>to reduce memory usage.</para>
        </listitem>

        <listitem>
          <para>to prevent problems with duplicate keys when persisting to
          BioSQL.</para>
        </listitem>
      </itemizedlist>

      <para>The singletons are kept in a LRU cache managed by a
      <code>RichObjectFactory</code>. See the chapter on this subject later in
      this book.</para>
    </section>
  </chapter>

  <chapter>
    <title>Future plans.</title>

    <section>
      <title>BioPerl and BioPerl-DB compatibility.</title>

      <para>We tried our best to store sequence data into BioSQL in the same
      way as BioPerl-DB does. We also tried to parse files in such a way that
      data from files would end up in the same place in BioSQL as if it had
      been parsed using the BioPerl file parsers then persisted using
      BioPerl-DB.</para>

      <para>However, we may not have been entirely successful, particularly
      with regard to the naming conventions of annotations and feature
      qualifiers, and the use of the document and publication cross-reference
      tables. Likewise, our definition of fuzzy locations may differ.</para>

      <para>So, we intend in the future to try and consolidate our efforts
      with those of the BioPerl and BioPerl-DB projects, along with any of the
      other Bio* projects who provide BioSQL persistence functionality, so
      that we can all read and write data to and from BioSQL in the same way.
      </para>

      <para>The goal is to be able to read a file with any of the Bio*
      projects, persist it to the database, then read it back from the
      database using any of the other Bio* projects and write it out to file.
      The input and output files should be logically identical (give or take
      some minor layout or formatting issues).</para>

      <para>Help is needed!</para>
    </section>

    <section>
      <title>Efficient parsing.</title>

      <para>The event-based parser model works great, but our implementations
      of actual file parsing code may leave a lot to be desired in terms of
      efficient use of memory or minimising the number of uses of markers in
      the input stream.</para>

      <para>If you are an IO, parsing, or code optimisation guru, you would be
      most welcome to come have a look and speed things up a bit.</para>
    </section>

    <section>
      <title>More file formats supported.</title>

      <para>We've provided parsers (and writers) for all the major formats we
      thought would be necessary. But there are only two of us, and it takes a
      while to trawl through the documentation for each format and try to
      shoehorn it all into the BioSQL model, even before the actual coding
      begins.</para>

      <para>If there's a format you like and use daily and you think would be
      of use to others, but you can't find it in BioJavaX, then please do
      write a parser for it and contribute it to the project.</para>
    </section>

    <section>
      <title>Persistence to non-BioSQL databases.</title>

      <para>Basically, right now, you can't. We have only provided Hibernate
      mappings for BioSQL. </para>

      <para>There is no reason though why you can't write a new set of
      Hibernate XML mapping files that map the BioJavaX objects into tables in
      some other database format. Because of the way Hibernate works, you
      wouldn't have to change any of the BioJavaX code at all, only the
      mapping files that tell Hibernate how to translate between objects and
      tables.</para>

      <para>If you do, and you think someone else could benefit from your
      work, please consider contributing them to the BioJava project for
      everyone to enjoy.</para>
    </section>

    <section>
      <title>Java 1.5 and Generics.</title>

      <para>Much discussion has occurred recently about upgrading BioJava to
      use features only available since version 1.5 of Java (also known as
      Java 5). Mostly we are considering the use of generics.</para>

      <para>A lot of this started after some Java 1.5 features accidentally
      slipped into the biojava-live CVS branch one day and suddenly nobody
      using older JVMs could compile it any more. These were quickly removed,
      and it was agreed to wait a while before a decision was made about the
      ultimate use of such features.</para>

      <para>Java 1.5 offers a lot of features that would be very useful in
      BioJava, and has the potential to greatly reduce the size of the
      project's codebase. However, 1.5 compilers and runtime environments are
      not available for some platforms yet, and in other situations companies
      are reluctant to upgrade when they have already settled on 1.4 as their
      tested and accepted Java environment.</para>

      <para>So, we won't do it yet, but we would definitely like to change in
      future.</para>
    </section>
  </chapter>

  <chapter>
    <title>Singletons and the <code>RichObjectFactory</code>.</title>

    <section>
      <title>Using <code>RichObjectFactory</code>.</title>

      <para>BioJavaX revolves around the use of singleton instances. This is
      important to keep memory usage down, and becomes even more important
      when working with BioSQL databases via Hibernate to prevent duplicate
      records in tables. Singletons are generated in a singleton
      factory.</para>

      <para><code>RichObjectFactory</code> is a caching singleton factory. If
      you request lots of instances of the same class, the oldest ones are
      forgotten about and you will get a new instance next time you ask for
      it. This is to prevent memory blowouts. The default size of this LRU
      cache is 20 instances of each class.</para>

      <para>Singletons are only important when dealing with certain
      classes:</para>

      <itemizedlist>
        <listitem>
          <para><code>SimpleNamespace</code></para>
        </listitem>

        <listitem>
          <para><code>SimpleComparableOntology</code></para>
        </listitem>

        <listitem>
          <para><code>SimpleNCBITaxon</code></para>
        </listitem>

        <listitem>
          <para><code>SimpleCrossRef</code></para>
        </listitem>

        <listitem>
          <para><code>SimpleDocRef</code></para>
        </listitem>
      </itemizedlist>

      <para>In all other cases, you don't need to worry about singletons. In
      fact, the singleton factory may complain if you try to ask it to make a
      singleton of any class not listed above.</para>

      <para>To generate a new instance of any of the above, you must use the
      <code>RichObjectFactory</code>. This tool checks an LRU cache to see if
      you have requested an identical instance recently. If you have, it
      returns that instance (a singleton). If you haven't, then it creates the
      instance, adds it to the LRU cache, then returns it.</para>

      <para>The parameters you supply to the <code>RichObjectFactory</code>
      are a class name, and an array of parameters which you would normally
      have passed directly to that class' constructor. Here is a list of the
      parameters required, and an example, for each of the classes accepted by
      the current factory:</para>

      <table>
        <title><code>RichObjectFactory</code> singleton examples.</title>

        <tgroup cols="3">
          <tbody>
            <row>
              <entry><code>SimpleNamespace</code></entry>

              <entry>[name (<code>String</code>)]</entry>

              <entry><programlisting>Namespace ns = (Namespace)RichObjectFactory.getObject(
                             Namespace.class, 
                             new Object[]{"myNamespace"}
                          );</programlisting></entry>
            </row>

            <row>
              <entry><code>SimpleComparableOntology</code></entry>

              <entry>[name (<code>String</code>)]</entry>

              <entry><programlisting>ComparableOntology ont = (ComparableOntology)RichObjectFactory.getObject(
                                                ComparableOntology.class, 
                                                new Object[]{"myOntology"}
                                             );</programlisting></entry>
            </row>

            <row>
              <entry><code>SimpleNCBITaxon</code></entry>

              <entry>[taxID (<code>Integer</code>)]</entry>

              <entry><programlisting>Integer taxID = new Integer(12345);
NCBITaxon tax = (NCBITaxon)RichObjectFactory.getObject(
                              SimpleNCBITaxon.class, 
                              new Object[]{taxID}
                           );</programlisting></entry>
            </row>

            <row>
              <entry><code>SimpleCrossRef</code></entry>

              <entry>[databaseName (<code>String</code>), accession
              (<code>String</code>), version (<code>Integer</code>)]</entry>

              <entry><programlisting>Integer version = new Integer(0);
CrossRef cr = (CrossRef)RichObjectFactory.getObject(
                           SimpleCrossRef.class, 
                           new Object[]{"PUBMED","56789",version}
                        );</programlisting></entry>
            </row>

            <row>
              <entry><code>SimpleDocRef</code></entry>

              <entry>[authors (<code>List</code> of
              <code>DocRefAuthor</code>), location
              (<code>String</code>)]</entry>

              <entry><programlisting>DocRefAuthor author = new SimpleDocRefAuthor("Bloggs,J.");
List authors = new ArrayList();
authors.add(author);
DocRef dr = (DocRef)RichObjectFactory.getObject(
                       SimpleDocRef.class, 
                       new Object[]{authors,"Journal of Voodoo Virology, 2005, 23:55-57"}
                    );</programlisting></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>Where the singletons come from.</title>

      <para>The actual instances of the classes requested are generated using
      a <code>RichObjectBuilder</code>. The default
      <code>RichObjectBuilder</code>, <code>SimpleRichObjectBuilder</code>,
      uses introspection to call the constructors on the classes and create
      new instances. You do not need to do anything to set this up.</para>

      <para>If you do decide to write your own <code>RichObjectBuilder</code>
      for whatever reason, you can set it to be used by
      <code>RichObjectFactory</code> like this:</para>

      <programlisting>RichObjectBuilder builder = ...; // create your own one here
RichObjectFactory.setRichObjectBuilder(builder); // make the factory use it from now on</programlisting>

      <para>If you change the default <code>RichObjectBuilder</code> to a
      different one, you must do so at the very beginning of your program
      before any call to the <code>RichObjectFactory</code> has been made.
      This is because when the builder is changed, existing singletons or
      default instances are not removed. If you do not follow this guideline,
      you will end up with a mix of objects in the cache created by two
      different builders, which could lead to interesting situations.</para>
    </section>

    <section>
      <title>Hibernate singletons.</title>

      <para>When working with Hibernate, you must instantiate the
      <code>HibernateRichObjectBuilder</code>. When using this, instances are
      looked up in the underlying BioSQL database first to see if they exist.
      If they do, they are loaded and returned. If not, they are created, then
      returned.</para>

      <para>The instances returned by <code>RichObjectFactory</code> when
      using the <code>HibernateRichObjectBuilder</code> are guaranteed true
      singletons and will never be duplicated even if you fill up the LRU
      cache several times between requests.</para>

      <para>See the section on BioSQL and Hibernate later in this document for
      more details.</para>
    </section>

    <section>
      <title>Managing the LRU cache.</title>

      <para>By default, the LRU cache keeps the 20 most recently requested
      instances of any given class in memory. If more than 20 objects are
      requested, the oldest ones are removed from the cache before the new
      ones are added. This keeps memory usage at a minimum.</para>

      <para>If you are experiencing problems with duplicate instances when you
      expected singletons., or believe that a larger or smaller cache may help
      the performance of your application, then you can change the size of the
      LRU cache. There are two ways of doing this.</para>

      <para>Changes to the LRU cache size are not instantaneous. The size of
      the cache only changes physically next time an instance is requested
      from it. Even then, only the cache of instances of the class requested
      will actually change.</para>

      <section>
        <title>Global LRU cache size.</title>

        <para>Changing the global LRU cache size will change the cache size
        for all classes. It applies the new cache size to every single class.
        Next time any of those classes are accessed via the RichObjectFactory,
        the LRU cache for that class will adjust to the new size.</para>

        <programlisting>RichObjectFactory.setLRUCacheSize(50); // increases the global LRU cache size to 50 instances per class</programlisting>
      </section>

      <section>
        <title>Class-specific LRU cache size.</title>

        <para>Changing the LRU cache size for a specific class will only
        affect that class. Your class-specific settings will be lost if you
        later change the global LRU cache size.</para>

        <programlisting>RichObjectFactory.setLRUCacheSize(SimpleNamespace.class, 50); // increases the LRU cache for SimpleNamespace instances to 50</programlisting>
      </section>
    </section>

    <section>
      <title>Convenience methods.</title>

      <para>A number of convenience methods are provided by the
      RichObjectFactory to allow easy access to some useful default
      singletons:</para>

      <table>
        <title><code>RichObjectFactory</code> convenience methods.</title>

        <tgroup cols="2">
          <tbody>
            <row>
              <entry><code>void setDefaultNamespaceName(String
              name);</code></entry>

              <entry>Sets the name of the default namespace. This namespace is
              used when loading files which have no namespace information of
              their own, and when no namespace has been passed to the file
              loading routines. It can also be used when creating temporary
              <code>RichSequence</code> or <code>BioEntry</code> objects, as
              the namespace parameter is compulsory on these objects.</entry>
            </row>

            <row>
              <entry><code>Namespace getDefaultNamespace();</code></entry>

              <entry>Returns the default namespace singleton instance
              (delegates to <code>getObject()</code>).</entry>
            </row>

            <row>
              <entry><code>void setDefaultOntologyName(String
              name);</code></entry>

              <entry>Sets the name of the default ontology. When parsing
              files, new terms are often created. If the file format does not
              have an ontology of its own, then it will use the default
              ontology to store these terms. Terms commonly used throughout
              BioJavaX, including those common to all file formats, are also
              stored in the default ontology.</entry>
            </row>

            <row>
              <entry><code>ComparableOntology
              getDefaultOntology();</code></entry>

              <entry>Returns the default ontology singleton instance
              (delegates to <code>getObject()</code>).</entry>
            </row>

            <row>
              <entry><code>void setDefaultPositionResolver(PositionResolver
              pr);</code></entry>

              <entry>When converting fuzzy locations into actual physical
              locations, a <code>PositionResolver</code> instance is used. The
              default one is <code>AveragePositionResolver</code>, which
              averages out the range of fuzziness to provide a value somewhere
              in the middle. You can override this setting using this
              function. All locations that are resolved without explicility
              specifying a <code>PositionResolver</code> to use will then use
              this resolver to do the work.</entry>
            </row>

            <row>
              <entry><code>PositionResolver
              getDefaultPositionResolver();</code></entry>

              <entry>Returns the default position resolver.</entry>
            </row>

            <row>
              <entry><code>void
              setDefaultCrossReferenceResolver(CrossReferenceResolver
              cr);</code></entry>

              <entry><code>CrossRef</code> instances are links to other
              databases. When a <code>CrossRef</code> is used in a
              <code>RichLocation</code> instance, it means that to obtain the
              symbols (sequence) for that location, it must first retrieve the
              remote sequence object. The <code>CrossReferenceResolver</code>
              object specified using this method is used to carry this out.
              The only implementation of this interface at present is
              <code>SimpleCrossReferenceResolver</code>, which is the one used
              by default.</entry>
            </row>

            <row>
              <entry><code>CrossReferenceResolver
              getDefaultCrossReferenceResolver();</code></entry>

              <entry>Returns the default cross reference resolver.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>Default settings.</title>

      <para>The default namespace name is <code>lcl</code>.</para>

      <para>The default ontology name is <code>biojavax</code>.</para>

      <para>The default LRU cache size is 20.</para>

      <para>The default position resolver is
      <code>AveragePositionResolver</code>.</para>

      <para>The default cross reference resolver is
      <code>SimpleCrossReferenceResolver</code>.</para>
    </section>
  </chapter>

  <chapter>
    <title><code>BioEntry</code> vs. <code>RichSequence</code>.</title>

    <section>
      <title>Two-tier definition.</title>

      <para>BioJavaX has a two-tier definition of sequence data.</para>

      <para>BioEntry objects correspond to the bioentry table in BioSQL. They
      do not have any sequence information, and neither do they have any
      features. They can, however, be annotated, commented, and put into
      relationships with each other. They can also have cross-references to
      publications and other databases associated with them.</para>

      <para>RichSequence objects extend BioEntry objects by adding in sequence
      data and a feature table.</para>

      <para>So, when to use them?</para>

      <itemizedlist>
        <listitem>
          <para>BioEntry objects are most useful when performing simple
          operations such as counting sequences, checking taxonomy data,
          looking up accessions, or finding out things like which objects
          refer to a particular PUBMED entry.</para>
        </listitem>

        <listitem>
          <para>RichSequence objects are useful only when you need access to
          the sequence data itself, or to the sequence feature table.</para>
        </listitem>

        <listitem>
          <para>RichSequence objects must be used whenever you wish to pass
          objects to legacy code that is expecting Sequence objects, as only
          RichSequence objects implement the Sequence interface. BioEntry
          objects do not.</para>
        </listitem>
      </itemizedlist>

      <para>Throughout the rest of this document, both BioEntry and
      RichSequence objects will be referred to interchangeably as sequence
      objects.</para>
    </section>

    <section>
      <title>Multiple accessions.</title>

      <para>If you wish to assign multiple accessions to a sequence, you must
      do so using the special term provided, like this:</para>

      <programlisting>ComparableTerm accTerm = RichSequence.Terms.getAdditionalAccessionTerm();
Note accession1 = new SimpleNote(accTerm,"A12345",1); // this note has an arbitrary rank of 1
Note accession2 = new SimpleNote(accTerm,"Z56789",2); // this note has an arbitrary rank of 2
...
RichSequence rs = ...; // get a rich sequence from somewhere
rs.getNoteSet().add(accession1); // annotate the rich sequence with the first additional accession
rs.getNoteSet().add(accession2); // annotate the rich sequence with the second additional accession
...
// you can annotate bioentry objects in exactly the same way
BioEntry be = ...; // get a bioentry from somewhere
be.getNoteSet().add(annotation1); 
be.getNoteSet().add(annotation2); </programlisting>

      <para>See later in this document for more information on how to annotate
      and comment on sequences.</para>
    </section>
  </chapter>

  <chapter>
    <title>Reading and writing files.</title>

    <section>
      <title>Tools for reading/writing files.</title>

      <para></para>
    </section>

    <section>
      <title>FASTA.</title>

      <para></para>
    </section>

    <section>
      <title>GenBank.</title>

      <para></para>
    </section>

    <section>
      <title>EMBL.</title>

      <para></para>
    </section>

    <section>
      <title>UniProt.</title>

      <para></para>
    </section>

    <section>
      <title>INSDSeq (XML).</title>

      <para></para>
    </section>

    <section>
      <title>EMBLxml (XML).</title>

      <para></para>
    </section>

    <section>
      <title>UniProtXML (XML).</title>

      <para></para>
    </section>
  </chapter>

  <chapter>
    <title>Being creative with <code>RichSequenceListener</code>.</title>

    <para></para>
  </chapter>

  <chapter>
    <title>Publication cross-references.</title>

    <section>
      <title>Everything is a 'journal article'.</title>

      <para></para>
    </section>

    <section>
      <title>Editors and consortiums as authors.</title>

      <para></para>
    </section>

    <section>
      <title>Tools for working with references.</title>

      <para></para>
    </section>
  </chapter>

  <chapter>
    <title>Database cross-references.</title>

    <section>
      <title>Database names.</title>

      <para></para>
    </section>

    <section>
      <title>Primary accessions.</title>

      <para></para>
    </section>

    <section>
      <title>Secondary or multiple accessions.</title>

      <para></para>
    </section>
  </chapter>

  <chapter>
    <title>Relationships between features.</title>

    <para></para>
  </chapter>

  <chapter>
    <title>Relationships between sequences.</title>

    <para></para>
  </chapter>

  <chapter>
    <title>Working with <code>RichLocation</code> objects.</title>

    <section>
      <title>Tools for working with locations.</title>

      <para></para>
    </section>

    <section>
      <title>Strandedness.</title>

      <para></para>
    </section>

    <section>
      <title>Remote locations.</title>

      <para></para>
    </section>

    <section>
      <title><code>Position</code> objects and fuzziness.</title>

      <para></para>
    </section>

    <section>
      <title>Empty locations.</title>

      <para></para>
    </section>

    <section>
      <title>Simple locations.</title>

      <para></para>
    </section>

    <section>
      <title>Compound locations.</title>

      <para></para>
    </section>

    <section>
      <title>Multi-sequence/multi-strand locations.</title>

      <para></para>
    </section>

    <section>
      <title>Circular locations.</title>

      <para></para>
    </section>

    <section>
      <title>Union.</title>

      <para></para>
    </section>

    <section>
      <title>Intersection.</title>

      <para></para>
    </section>

    <section>
      <title>Overlaps.</title>

      <para></para>
    </section>

    <section>
      <title>Contains.</title>

      <para></para>
    </section>

    <section>
      <title>Flattening for storage in BioSQL.</title>

      <para></para>
    </section>

    <section>
      <title>Symbols.</title>

      <para></para>
    </section>
  </chapter>

  <chapter>
    <title>Features</title>

    <section>
      <title>Adding features to a <code>RichSequence</code>.</title>

      <para></para>
    </section>

    <section>
      <title>Qualifiers are annotations.</title>

      <para></para>
    </section>
  </chapter>

  <chapter>
    <title>Annotations and Comments.</title>

    <section>
      <title>Annotations.</title>

      <para></para>
    </section>

    <section>
      <title>Comments.</title>

      <para></para>
    </section>

    <section>
      <title>UniProt-style comments.</title>

      <para></para>
    </section>
  </chapter>

  <chapter>
    <title>Namespaces.</title>

    <section>
      <title>Obtaining namespace instances.</title>

      <para>All sequences in BioJavaX must belong to a namespace, by being
      associated with an instance of the <code>Namespace</code> interface.
      This is in line with BioSQL.</para>

      <para>A default namespace is provided by the
      <code>RichObjectFactory</code>:</para>

      <programlisting>// get the default namespace
Namespace defaultNS = RichObjectFactory.getDefaultNamespace(); 
...
// make a custom namespace
Namespace customNS = (Namespace)RichObjectFactory.getObject(SimpleNamespace.class, new Object[]{"myNameSpace"}); 
...
// load a namespace from BioSQL, or create it if it doesn't exist yet
Namespace biosqlNS = (Namespace)HibernateRichObjectFactory.getObject(SimpleNamespace.class, new Object[]{"myBioSQLNameSpace"});
...
// change the default namespace to "bloggsNS"
RichObjectFactory.setDefaultNamespace("bloggsNS");</programlisting>
    </section>
  </chapter>

  <chapter>
    <title>BioSQL.</title>

    <section>
      <title>Introduction to Hibernate.</title>

      <para></para>
    </section>

    <section>
      <title>Configuring your application to use Hibernate and BioSQL.</title>

      <para></para>
    </section>

    <section>
      <title>The <code>HibernateRichObjectBuilder</code>.</title>

      <para></para>
    </section>

    <section>
      <title>Transactions.</title>

      <para></para>
    </section>

    <section>
      <title>Flattened locations.</title>

      <para></para>
    </section>

    <section>
      <title>Persisting objects.</title>

      <para></para>
    </section>

    <section>
      <title>Loading objects.</title>

      <para></para>
    </section>

    <section>
      <title>Loading individual values from objects.</title>

      <para></para>
    </section>

    <section>
      <title>Auto-generating the BioSQL schema.</title>

      <para></para>
    </section>

    <section>
      <title>Dumping objects as XML.</title>

      <para></para>
    </section>
  </chapter>
</book>
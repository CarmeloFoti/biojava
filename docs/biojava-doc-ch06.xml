<!--DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
                      "file:///usr/share/sgml/docbook/xml-dtd/docbookx.dtd" [
]-->

<chapter id="bd-search">
  <title>Representing Search Results</title>

  <abstract id="bd-search-abstract">
    <para>This chapter covers BioJava's support for processing the
    output from common sequence similarity search programs such as
    Blast and Fasta. The Java API referred to in this chapter is
    located in the packages
    <classname>org.biojava.bio.search</classname>,
    <classname>org.biojava.bio.program.sax</classname>,
    <classname>org.biojava.bio.program.ssbind</classname> and
    <classname>org.biojava.bio.program.blast2html</classname>. For a
    complete overview of the APIs provided by these packages, please
    consult the <ulink url="api/index.html">JavaDoc
    documentation</ulink>.</para>
  </abstract>

  <sect1 id="bd-search-represent">
    <title>A tour of search results</title>

    <para>Sequence similarity search programs are amongst the most
    commonly used tools in bioinformatics. Their use is often
    characterised by the need to process and organise large amounts of
    program output in loosely specified formats which undergo subtle
    changes between program versions. BioJava has a common set of
    interfaces and classes for representing sequence similarity search
    results and also goes some way to addressing the problem of
    disparate output formats by offering the Blast-like parsing
    framework. This produces SAX2 events conforming to a common DTD
    for NCBI Blast, Wu Blast, Fasta and HMMER.</para>

    <para>The package <classname>org.biojava.bio.search</classname>
    contains interfaces and classes purely for representing sequence
    similarity search results, regardless of the program that supplied
    the original data. When a query sequence is searched against a
    database of other sequences, the entire set of database hits is
    known as a "result". These are represented by the interface
    <classname> SeqSimilaritySearchResult</classname>:</para>

<programlisting>
public interface SeqSimilaritySearchResult {
    String getQueryID();
    String getDatabaseID();
    Map getSearchParameters();
    List getHits();
}
</programlisting>

    <para>As you can see, the result interface also specifies that
    instances are capable of returning the query sequence ID as a
    <classname>String</classname> and the target database ID as a
    <classname>String</classname>. The search parameters may not be
    available, so the <methodname>getSearchParameters</methodname>
    method is permitted to return null. The individual database hits
    are returned as a <classname>List</classname> whose order should
    be specified by the implementation. The
    <classname>SeqSimilaritySearchHit</classname> interface defines
    accessors for the hit data, using the Blast terminology of "query"
    for the sequence being searched against the database and "subject"
    for a sequence in the database which is hit.</para>

<programlisting>
public interface SeqSimilaritySearchHit {
    public double getScore();
    public double getPValue();
    public double getEValue();
    public int getQueryStart();
    public int getQueryEnd();
    public Strand getQueryStrand();
    public int getSubjectStart();
    public int getSubjectEnd();
    public Strand getSubjectStrand();
    public String getSubjectID();
    public List getSubHits();
}
</programlisting>

    <para>The exact behaviour of each method is given in the API
    documentation (notably, that "score" is the only mandatory field
    describing degree of similarity and that the methods returning a
    <classname>Strand</classname> are permitted to return null for
    protein sequences). In Blast terms, a hit represents a collection
    of HSPs, with the list of HSPs which constitute the hit being
    returned by the <methodname>getSubHits</methodname> method. Each
    sub-hit is described by the interface
    <classname>SeqSimilaritySearchSubHit</classname>:</para>

<programlisting>
public interface SeqSimilaritySearchSubHit {
    public double getScore();
    public double getPValue();
    public double getEValue();
    public int getQueryStart();
    public int getQueryEnd();
    public Strand getQueryStrand();
    public int getSubjectStart();
    public int getSubjectEnd();
    public Strand getSubjectStrand();
    public Alignment getAlignment();
}
</programlisting>

    <para>The most important additional method available on the
    sub-hits is <methodname>getAlignment</methodname> which returns
    an alignment corresponding to the sub-hit region.</para>

    <para>These interfaces intentionally present a rather limited view
    of possible result data. There are simple implementations which
    provide nothing more than the methods described above. However,
    the preferred implementations are
    <classname>SequenceDBSearchResult</classname>,
    <classname>SequenceDBSearchHit</classname> and
    <classname>SequenceDBSearchSubHit</classname>. The first two of
    these also implement <classname>Annotatable</classname>, thus
    allowing arbitrary additional information from the search program
    to be stored in an <classname>Annotation</classname>
    object.</para>

    <para>The following sections describe how you can create instances
    of these and other objects from program output and also create XML
    conforming to the BioJava BlastLikeDataSetCollection DTD.</para>
  </sect1>

  <sect1 id="bd-search-blastlike">
    <title>The Blast-like parsing framework</title>

    <para>The Blast-like parsing framework is a system which parses
    the report files produced by a number of programs, including NCBI
    Blast, WU-Blast, HMMER and Fasta, yielding a stream of SAX2 events
    which conform to a single XML DTD. This allows you to focus on the
    content of the reports, rather than worrying about their different
    formats. Facade classes conceal the details of the parsing system,
    leaving only the implementation of
    <classname>ContentHandler</classname>s for the data you are
    interested in and as there is a single DTD shared between several
    analysis programs, there is potential for re-use of those
    <classname>ContentHandler</classname>s. BioJava provides some
    ready-made <classname>StAXContentHandler</classname>s in the
    <classname>org.biojava.bio.program.ssbind</classname> package and
    also the <classname>org.biojava.utils.stax</classname> package for
    writing modular XML handlers of your own.</para>

    <sect2 id="bd-search-fromblast">
      <title>Creating objects from Blast output</title>

      <para>This example assumes that you have some Blast search
      results in a file. However, the changes required to process
      output from another source such as a running Blast program are
      minimal; simply create the relevant
      <classname>InputStream</classname>.</para>

      <para>Create a <classname>BlastLikeSAXParser</classname> to be
      the source of SAX events. The
      <classname>ContentHandler</classname> for these events is a
      <classname>SeqSimilarityAdapter</classname> which is an adapter
      class which converts the SAX events into method calls on a
      <classname>SearchContentHandler</classname>. There are various
      <classname>SearchContentHandler</classname> implementations in
      the <classname>org.biojava.bio.program.ssbind</classname>
      package, each of which build different types of object. Here we
      use <classname>BlastLikeSearchBuilder</classname>, which creates
      <classname>SequenceDBSearchResult</classname>s.</para>

<programlisting>
InputStream searchStream = new BufferedInputStream(new
    FileInputStream(blastFileName));

XMLReader reader = (XMLReader) new BlastLikeSAXParser();
SeqSimilarityAdapter adapter = new SeqSimilarityAdapter();
reader.setContentHandler(adapter);

List searchResults = new ArrayList(50);
BlastLikeSearchBuilder builder = new BlastLikeSearchBuilder(searchResults);

adapter.setSearchContentHandler(builder);
</programlisting>

      <para>Once the builder is set up, calling the
      <methodname>parse</methodname> method on the
      <classname>BlastLikeSAXParser</classname> will populate the
      <classname>List</classname> passed to its constructor with
      <classname>SequenceDBSearchResult</classname>s.</para>

<programlisting>
reader.parse(new InputSource(searchStream));
</programlisting>

      <para>The result objects may then be examined.</para>

<programlisting>
for (Iterator ri = searchResults.iterator(); ri.hasNext();) {
    SeqSimilaritySearchResult result =
        (SeqSimilaritySearchResult) ri.next();

    printResult(result);
}
</programlisting>

      <para>The <classname>BlastLikeSearchBuilder</classname> operates
      a simple strategy of instantiating all available results in
      memory. This will not be acceptable in many situations such as
      where there are very long streams of results, or where results
      need to be filtered by score, coverage or otherwise selectively
      instantiated. The solution here is to write your own handler
      which does exactly what you want. You may find that you can
      re-use some of the modular handlers in the package to help
      you.</para>
    </sect2>

    <sect2 id="bd-search-fromfasta">
      <title>Creating objects from Fasta output</title>

      <para>The procedure for creating
      <classname>SequenceDBSearchResult</classname>s from the output
      of the Fasta search program is almost identical. The difference
      is in the initial SAX event generator.</para>

<programlisting>
XMLReader reader = (XMLReader) new FastaSearchSAXParser();
SeqSimilarityAdapter adapter = new SeqSimilarityAdapter();
reader.setContentHandler(adapter);
</programlisting>
    </sect2>

      <sect2>
        <title>More complex builders</title>

        <para>The <classname>BlastLikeSearchBuilder</classname> refers
        to sequences and databases by simple identifier strings. It is
        left to the programmer to decide whether they want to resolve
        these to actual <classname>Sequence</classname> or
        <classname>SequenceDB</classname> instances. However, some
        builder implementations actually require the ability to do
        this themselves, on demand. For example,
        <classname>SimilarityPairBuilder</classname> annotates paired
        <classname>Sequence</classname>s with
        <classname>Feature</classname>s which represent regions of
        similarity and therefore requires
        <classname>Sequence</classname> objects, not just their
        identifiers.</para>

        <para>The strategy used by
        <classname>SimilarityPairBuilder</classname> is typical of
        this type of class. It must be primed with two sources of
        data. The first is a <classname>SequenceDB</classname>
        containing all of the query sequences used to create the Blast
        results in the stream (bear in mind that there may be many
        reports in the same stream) and the second is a
        <classname>SequenceDBInstallation</classname> which contains
        <classname>SequenceDB</classname>s representing all of the
        databases searched against. These may seem like excessive
        requirements, yet once in place any combination of query and
        database in the stream can be handled. If the sequences and
        databases are unavailable then anonymous inner classes which
        implement limited but sufficient functionality could be
        used. For example a simple <classname>SequenceDB</classname>
        which always returns the same empty
        <classname>Sequence</classname> and a
        <classname>SequenceDBInstallation</classname> which always
        returns that <classname>SequenceDB</classname> could be
        used. Take care that any such implementations are not exposed
        in places where they could surprise others!</para>

<programlisting>
builder.setQuerySeqHolder(queryDB);
builder.setSubjectDBInstallation(dbs);
</programlisting>

      </sect2>
  </sect1>

  <sect1 id="bd-search-blastnative">
    <title>Handling native Blast XML</title>

    <para>NCBI Blast now produces result data its own XML
    format. Currently we do not include any handlers for this
    output. Support is on the to-do list, probably in the form of an
    <classname>XMLFilter</classname> to perform a transformation to
    the BioJava DTD or XSLT. The former is more likely as the latter
    introduces an extra library dependency for the XSL
    transformer (probably Apache Xalan-Java).</para>
  </sect1>
  </chapter>
<!--DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
                      "file:///usr/share/sgml/docbook/xml-dtd/docbookx.dtd" [
]-->

<chapter id="bd-motifs">
  <title>Motifs and Restriction Sites in
  <classname>SymbolLists</classname></title>

  <abstract id="bd-motifs-abstract">
    <para>This chapter describes how to perform simple pattern
    searches on <classname>SymbolLists</classname>s and includes
    coverage of BioJava's support for restriction enzymes. The Java
    API referred to in this chapter is located in the packages
    <classname>org.biojava.bio.symbol</classname>,
    <classname>org.biojava.bio.molbio</classname>, and
    <classname>org.biojava.bio.search</classname>. For a complete
    overview of the APIs provided by these packages, please consult
    the <ulink url="api/index.html">JavaDoc
    documentation</ulink>.</para>
  </abstract>

    <sect1 id="bd-motifs-types">
    <title>Types of motif search</title>

    <para>This chapter covers searching for exact matches and for
    patterns defined by regular expressions. It does not address more
    advanced possibilities, such as searches using hidden Markov
    models, which are possible using packages in the BioJava API other
    than those mentioned above.</para>

    <para>As BioJava uses a model of biological sequences which is not
    based on character strings (described in <xref
    linkend="bd-symbols-sym"/>) <classname>SymbolList</classname>s may
    not be used directly by standard Java string-searching or regular
    expression classes. However, a simple decorator (Decorator design
    pattern <xref linkend="bd-biblio-GoF98"/>) for
    <classname>java.lang.CharSequence</classname>,
    <classname>org.biojava.bio.seq.io.SymbolListCharSequence</classname>,
    is provided to allow <classname>SymbolList</classname>s efficient
    access to these classes. More on this in <xref
    linkend="bd-motifs-regex"/>.</para>
    </sect1>

  <sect1 id="bd-motifs-exact">
    <title>Finding exact matches</title>

    <para><classname>SymbolList</classname>s are amenable to standard
    string indexing and searching techniques. Currently the best way
    to find an exact match in a sequence (without using regular
    expressions) is using
    <classname>KnuthMorrisPrattSearch</classname> in the
    <classname>org.biojava.bio.search</classname> package. This
    implements the Knuth, Morris and Pratt search algorithm <xref
    linkend="bd-biblio-KMP77"/>. The algorithm finds exact matches
    therefore ambiguity symbols will match only themselves. The class
    operates on all alphabets thus if searching for a DNA pattern you
    should compile both the pattern and its reverse complement. The
    following example searches for "aagctt" within a longer
    sequence.</para>

<programlisting>
SymbolList syms = DNATools.createDNA("tttttataaagcttgtagatggatata");
SymbolList pattern = DNATools.createDNA("aagctt");

KnuthMorrisPrattSearch search = new KnuthMorrisPrattSearch(pattern);
int [] indices = search.findMatches(pattern);
</programlisting>

    <para>Calling <methodname>search</methodname> returns an array of
    integers which are the start indices of every occurrence of the
    query in the sequence being searched.</para>

    <para>It is also possible to index
    <classname>SymbolList</classname>s using a trie or suffix
    tree. Although the <classname>org.biojava.bio.symbol</classname>
    package includes a suffix tree implementation, it's probably best
    to use the KMP matcher unless you really know what you are doing
    as there is no easy API for using the tree to find patterns once
    it has been created.</para>
    </sect1>

  <sect1 id="bd-motifs-regex">
    <title>Finding regular expression matches</title>

    <para>To find a regular expression in a
    <classname>SymbolList</classname> you first need to create a
    <classname>CharSequence</classname> from it. There are two
    restrictions on the type of <classname>SymbolList</classname>
    which may be used.</para>
    <itemizedlist>
      <listitem>
        <para>Only <classname>SymbolList</classname>s using a
          <classname>FiniteAlphabet</classname> are supported.</para>
      </listitem>
      <listitem>
        <para>Only <classname>FiniteAlphabet</classname>s using a
          character token are supported. (A token is BioJava's term
          for an ASCII character representation of a
          <classname>Symbol</classname> object.</para>
      </listitem>
    </itemizedlist>

    <para>These are logical requirements; there must be a finite
    choice of <classname>Symbol</classname>s at each index and it must
    be possible to represent each <classname>Symbol</classname> as a
    single character. To create a <classname>CharSequence</classname>
    is simple.</para>

<programlisting>
SymbolList syms = DNATools.createDNA("tttttataaagcttgtagatggatata");
CharSequence seq = new SymbolListCharSequence(syms);
</programlisting>

    <para>This process does not copy the
    <classname>SymbolList</classname> and so is space
    efficient. Should the underlying sequence be mutated, these
    changes will be reflected in the
    <classname>CharSequence</classname>. From this point the regular
    expression API may be used as normal.</para>

<programlisting>
Pattern p = Pattern.compile("ta{2,10}gc");
Matcher m = p.matcher(seq);

while (m.find())
{
    int idx = m.start();
    System.out.println("Match at sequence index " + (idx + 1));
}
</programlisting>

    <para>A method <methodname>createRegex(SymbolList
    motif)</methodname> in the utility class
    <classname>org.biojava.bio.symbol.MotifTools</classname> is
    provided to automatically create regular expressions from
    <classname>SymbolList</classname>s which may contain
    ambiguities. A <classname>Pattern</classname> created from one of
    these regular expressions will find all matching motifs in a
    target <classname>CharSequence</classname>.</para>
  </sect1>

  <sect1 id="bd-motifs-restrict">
    <title>Applied regular expressions - restriction enzymes</title>

    <para>The basic regular expression framework has been integrated
    into BioJava's support for representing restriction enzymes. The
    <classname>org.biojava.bio.molbio.RestrictionEnzyme</classname>
    class is used to represent a restriction enzyme according to the
    <ulink url="http://rebase.neb.com">REBASE</ulink> standard and
    includes methods such as <methodname>getForwardRegex</methodname>
    and <methodname>getReverseRegex</methodname> which return regular
    expressions which may be used as described in <xref
    linkend="bd-motifs-regex"/>. Of course, this is only part of the
    story because the sequence position returned will be the first
    base of the recognition site rather than the position(s) of the
    cut site(s) themselves. <classname>RestrictionEnzyme</classname>
    provides two methods which allow the cut site(s) to be derived;
    <methodname>getUpstreamCut</methodname> returns an array of two
    ints which are the coordinates of the cuts in the forward and
    reverse strands upstream of the recognition site and
    <methodname>getDownstreamCut</methodname> returns an array of two
    ints which are the coordinates of the cuts in the forward and
    reverse strands within or downstream of the recognition site. All
    of these coordinates are in the coordinate space of the
    recognition site <classname>SymbolList</classname>s, as in the
    convention used by REBASE.</para>

    <sect2>
      <title>Creating <classname>RestrictionEnzyme</classname>s</title>

      <para>Most <classname>RestrictionEnzyme</classname> instances
      are expected to be created by the
      <classname>RestrictionEnzymeManager</classname>. This class
      manages collections of static
      <classname>RestrictionEnzyme</classname> instances and is
      capable of creating them automatically from a REBASE database
      flat file. It provides static methods for retrieving enzymes by
      name, recognition site length or isosizomers and for obtaining
      <classname>Pattern</classname>s which match the recognition site
      on the forward or reverse strands.</para>

      <sidebar>
        <title>Setting up a local REBASE</title>

        <procedure>
          <step>
            <para>Obtain a REBASE file in format #31 (conventionally
            named withrefm.### where ### is the version
            number).</para>
            </step>
            <step>
              <para>Create a standard Java properties file named
              'RestrictionEnzymeManager.properties' containing a key
              'rebase.data.file' and a corresponding value pointing to
              the REBASE file.</para>
            </step>
            <step>
              <para>Place the RestrictionEnzymeManager.properties file
              on the CLASSPATH where it will be loaded as a
              <classname>ResourceBundle</classname> by the
              <classname>RestrictionEnzymeManager</classname>.</para>
            </step>
          </procedure>
        </sidebar>
      </sect2>

      <sect2>
        <title>Marking restriction sites on a
        <classname>Sequence</classname></title>

        <para><classname>RestrictionMapper</classname> is a class for
        annotating <classname>Sequence</classname>s with
        <classname>Feature</classname>s which represent restriction
        sites. Calling <methodname>annotate(Sequence
        sequence)</methodname> will annotate the
        <classname>Sequence</classname> with the sites of any
        <classname>RestrictionEnzyme</classname>s which have been
        added to the <classname>RestrictionMapper</classname>. The
        returned <classname>Sequence</classname> is a
        <classname>ViewSequence</classname> wrapping the
        original.</para>

       <para>The <classname>Feature</classname>s created are
       <classname>RestrictionSite</classname>s which have a flyweight
       <classname>Annotation</classname> containing a single
       <classname>String</classname> property "dbxref" whose value is
       "REBASE:" plus name of the enzyme (e.g. EcoRI).</para>

       <para>The mapper will by default map only those sites which
       have both their recognition sites and their cut sites within
       the <classname>Sequence</classname>. This behaviour may be
       changed to map all sites which have their recognition sites
       within the <classname>Sequence</classname> using the
       <methodname>setMapAll(boolean on)</methodname> method. The
       current implementation requires that
       <classname>RestrictionEnzyme</classname>s to be searched must
       first be registered with the
       <classname>RestrictionEnzymeManager</classname>.</para>

        <para>The mapper relies on a <classname>ThreadPool</classname>
        to carry out searches for multiple sites concurrently. A
        simple pool implementation is provided by
        <classname>org.biojava.utils.SimpleThreadPool</classname> and
        because the mapper only requires a pool implementing the
        <classname>ThreadPool</classname> interface, it is possible to
        plug in third party pool implementations if required.</para>

<programlisting>
Set sixCutters = RestrictionEnzymeManager.getNCutters(6);

ThreadPool pool = new SimpleThreadPool();

RestrictionMapper mapper = new RestrictionMapper(pool);

for (Iterator ei = sixCutters.iterator(); ei.hasNext();)
{
    RestrictionEnzyme re = (RestrictionEnzyme) ei.next();
    mapper.addEnzyme(re);
}

Sequence seq = getSequence();
Sequence annotated = mapper.annotate(seq);
</programlisting>

    <para>There are additional factors to take into account in
      deciding which, if any, of the sites marked up by this
      procedure will actually be cut in a given situation. The
      current implementation does not have built-in support for
      calculating the effects of single-stranded regions created by
      earlier cuts, effects caused by proximity of sites to the ends
      of a sequence, methylation, temperature, reaction buffer
      composition or star activity.</para>
    </sect2>
  </sect1>
</chapter>

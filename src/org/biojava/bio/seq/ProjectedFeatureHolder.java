/*
 *                    BioJava development code
 *
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public Licence.  This should
 * be distributed with the code.  If you do not have a copy,
 * see:
 *
 *      http://www.gnu.org/copyleft/lesser.html
 *
 * Copyright for this code is held jointly by the individual
 * authors.  These should be listed in @author doc comments.
 *
 * For more information on the BioJava project and its aims,
 * or to join the biojava-l mailing list, visit the home page
 * at:
 *
 *      http://www.biojava.org/
 *
 */

package org.biojava.bio.seq;

import java.util.*;
import java.lang.reflect.*;

import org.biojava.utils.*;
import org.biojava.utils.bytecode.*;
import org.biojava.bio.*;
import org.biojava.bio.seq.impl.*;
import org.biojava.bio.seq.projection.*;
import org.biojava.bio.symbol.*;
import org.biojava.bio.program.das.*;

/**
 * Helper class for projecting Feature objects into an alternative
 * coordinate system.  This class offers a view onto a set of features,
 * projecting them into a different coordinate system, and also changing
 * their <code>parent</code> property.  The destination coordinate system
 * can run in the opposite direction from the source, in which case the
 * <code>strand</code> property of StrandedFeatures is flipped.
 *
 * <p>
 * The projected features returned by this class are small proxy objects.
 * Proxy classes are autogenerated on demand for any sub-interface of
 * <code>Feature</code>.  These <code>getLocation</code>, <code>getParent</code>,
 * <code>getSequence</code> and (where applicable) <code>getStrand</code> methods
 * of projected features may return different values from the underlying
 * feature.  All other methods are proxied directly.
 * </p>
 *
 * <p>
 * Originally, <code>ProjectedFeatureHolder</code> was a self-contained
 * class containing the full projection infrastructure.  Since BioJava
 * 1.2, most of the projection infrastructure has been moved to separate
 * classes in the package <code>org.biojava.bio.seq.projection</code>.
 * Custom applications may wish to use that code directly.
 * </p>
 *
 * @author Thomas Down
 * @author Matthew Pocock
 * @since 1.1
 */

public class ProjectedFeatureHolder extends AbstractFeatureHolder {
    private final FeatureHolder wrapped;
    private final FeatureHolder parent;
    private final int translate;
    private FeatureHolder projectedFeatures;
    private boolean oppositeStrand;
    private boolean cachingProjections = true;

    private FeatureFilter filter;

    private ChangeListener underlyingFeaturesChange;
    private PFHContext projectionContext;

    private static Location extractInterestingLocation(FeatureFilter ff) {
	if (ff instanceof FeatureFilter.OverlapsLocation) {
	    return ((FeatureFilter.OverlapsLocation) ff).getLocation();
	} else if (ff instanceof FeatureFilter.ContainedByLocation) {
	    return ((FeatureFilter.ContainedByLocation) ff).getLocation();
	} else if (ff instanceof FeatureFilter.And) {
	    FeatureFilter.And ffa = (FeatureFilter.And) ff;
	    Location l1 = extractInterestingLocation(ffa.getChild1());
	    Location l2 = extractInterestingLocation(ffa.getChild2());

	    if (l1 != null) {
		if (l2 != null) {
		    return l1.intersection(l2);
		} else {
		    return l1;
		}
	    } else {
		if (l2 != null) {
		    return l2;
		} else {
		    return null;
		}
	    }
	}

	// Don't know how this filter relates to location.

	return null;
    }
    

    public static FeatureHolder projectFeatureHolder(FeatureHolder fh,
						     FeatureHolder parent, 
						     int translation,
						     boolean flip)
    {
	if (fh instanceof DASOptimizableFeatureHolder) {
	    return new ProjectedOptimizedFeatureHolder((DASOptimizableFeatureHolder) fh,
						       parent,
						       translation,
						       flip);
	} else {
	    return new ProjectedFeatureHolder(fh, parent, translation, flip);
	}    
    }

    /**
     * Construct a new FeatureHolder which projects a set of features
     * into a new coordinate system.  If <code>translation</code> is 0
     * and <code>oppositeStrand</code> is <code>false</code>, the features
     * are simply reparented without any transformation.
     *
     * @param fh The set of features to project.
     * @param filter A FeatureFilter to apply to the set of features before projection.
     * @param parent The FeatureHolder which is to act as parent
     *               for the projected features.
     * @param translation The translation to apply to map locations into
     *                    the projected coordinate system.  This is the point
     *                    in the destination coordinate system which is equivalent
     *                    to 0 in the source coordinate system.
     * @param oppositeStrand <code>true</code> if translating into the opposite coordinate system.
     *                       This alters the transformation applied to locations, and also flips
     *                       the <code>strand</code> property of StrandedFeatures.
     */

    public ProjectedFeatureHolder(FeatureHolder fh,
				  FeatureFilter filter,
				  FeatureHolder parent, 
				  int translation,
				  boolean oppositeStrand) 
    {
	this.wrapped = fh;
	this.parent = parent;
	this.translate = translation;
	this.oppositeStrand = oppositeStrand;
	this.filter = filter;

	this.projectionContext = new PFHContext();

	underlyingFeaturesChange = new ChangeListener() {
	    public void preChange(ChangeEvent e)
		throws ChangeVetoException 
	    {
		if (changeSupport != null) {
		    changeSupport.firePreChangeEvent(new ChangeEvent(this,
								     FeatureHolder.FEATURES,
								     e.getChange(),
								     e.getPrevious(),
								     e));
		}
	    }

	    public void postChange(ChangeEvent e) {
		projectedFeatures = null; // Flush all the cached projections --
		                          // who knows what might have changed.

		if (changeSupport != null) {
		    changeSupport.firePostChangeEvent(new ChangeEvent(this,
								      FeatureHolder.FEATURES,
								      e.getChange(),
								      e.getPrevious(),
								      e));
		}
	    }
	} ;

	wrapped.addChangeListener(underlyingFeaturesChange);
    }

    public boolean isCachingProjections() {
	return cachingProjections;
    }

    /**
     * Determine whether or not the projected features should be cached.
     * This is a temporary optimization, and might go away once feature
     * filtering is more intelligent.
     *
     * @since 1.2
     */

    public void setIsCachingProjections(boolean b) {
	cachingProjections = b;
	projectedFeatures = null;
    }

    /**
     * Construct a new FeatureHolder which projects a set of features
     * into a new coordinate system.  If <code>translation</code> is 0
     * and <code>oppositeStrand</code> is <code>false</code>, the features
     * are simply reparented without any transformation.
     *
     * @param fh The set of features to project.
     * @param parent The FeatureHolder which is to act as parent
     *               for the projected features.
     * @param translation The translation to apply to map locations into
     *                    the projected coordinate system.  This is the point
     *                    in the destination coordinate system which is equivalent
     *                    to 0 in the source coordinate system.
     * @param oppositeStrand <code>true</code> if translating into the opposite coordinate system.
     *                       This alters the transformation applied to locations, and also flips
     *                       the <code>strand</code> property of StrandedFeatures.
     */

    public ProjectedFeatureHolder(FeatureHolder fh,
				  FeatureHolder parent, 
				  int translation,
				  boolean oppositeStrand) 
    {
	this(fh, null, parent, translation, oppositeStrand);
    }

    protected FeatureHolder getProjectedFeatures() {
	if (projectedFeatures != null) {
	    return projectedFeatures;
	}

	FeatureHolder toProject = wrapped;
	if (filter != null) {
	    toProject = toProject.filter(filter, false);
	}

	SimpleFeatureHolder sfh = new SimpleFeatureHolder();
	for (Iterator i = toProject.features(); i.hasNext(); ) {
	    Feature f = (Feature) i.next();
	    Feature wf = ProjectionEngine.DEFAULT.projectFeature(f, projectionContext);
	    try {
		sfh.addFeature(wf);
	    } catch (ChangeVetoException cve) {
		throw new BioError(
				   cve,
				   "Assertion failure: Should be able to manipulate this FeatureHolder"
				   );
	    }
	}

	if (cachingProjections) {
	    projectedFeatures = sfh;
	}

	return sfh;
    }

    public int countFeatures() {
	if (filter != null) {
	    return getProjectedFeatures().countFeatures();
	} else {
	    return wrapped.countFeatures();
	}
    }

    public Iterator features() {
	return getProjectedFeatures().features();
    }
    
    public boolean containsFeature(Feature f) {
      return getProjectedFeatures().containsFeature(f);
    }

    public FeatureHolder filter(FeatureFilter ff, boolean recurse) {
	return getProjectedFeatures().filter(ff, recurse);
    }

    public Location getProjectedLocation(Location oldLoc) {
	if (oppositeStrand) {
	    if (oldLoc.isContiguous()) {
		return new RangeLocation(translate - oldLoc.getMax(),
					 translate - oldLoc.getMin());
	    } else {
		Location compound = Location.empty;
		for (Iterator i = oldLoc.blockIterator(); i.hasNext(); ) {
		    Location oldBlock = (Location) i.next();
		    compound = compound.union(new RangeLocation(translate - oldBlock.getMax(),
								translate - oldBlock.getMin()));
		}
		return compound;
	    }
	} else {
	    return oldLoc.translate(translate);
	}
    }

    public int getTranslation() {
	return translate;
    }

    public boolean isOppositeStrand() {
	return oppositeStrand;
    }

    public FeatureHolder getParent() {
	return parent;
    }

    /**
     * ProjectionContext implementation tied to a given ProjectedFeatureHolder
     */

    private class PFHContext implements ProjectionContext {
	public FeatureHolder getParent(Feature f) {
	    return parent;
	}

	public Sequence getSequence(Feature f) {
	    FeatureHolder fh = parent;
	    while (fh instanceof Feature) {
		fh = ((Feature) fh).getParent();
	    }
	    return (Sequence) fh;
	}

	public Location getLocation(Feature f) {
	    Location oldLoc = f.getLocation();

	    if (oppositeStrand) {
		if (oldLoc.isContiguous()) {
		    return new RangeLocation(translate - oldLoc.getMax(),
					     translate - oldLoc.getMin());
		} else {
		    Location compound = Location.empty;
		    for (Iterator i = oldLoc.blockIterator(); i.hasNext(); ) {
			Location oldBlock = (Location) i.next();
			compound = compound.union(new RangeLocation(translate - oldBlock.getMax(),
								    translate - oldBlock.getMin()));
		    }
		    return compound;
		}
	    } else {
		return oldLoc.translate(translate);
	    }
	}

	public StrandedFeature.Strand getStrand(StrandedFeature sf) {
	    if (isOppositeStrand()) {
		StrandedFeature.Strand s = sf.getStrand();
		if (s == StrandedFeature.POSITIVE) {
		    return StrandedFeature.NEGATIVE;
		} else if (s == StrandedFeature.NEGATIVE) {
		    return StrandedFeature.POSITIVE;
		} else {
		    return StrandedFeature.UNKNOWN;
		}
	    } else {
		return sf.getStrand();
	    }
	}

	public Annotation getAnnotation(Feature f) {
	    return f.getAnnotation();
	}

	public FeatureHolder projectChildFeatures(Feature f, FeatureHolder parent) {
	    return projectFeatureHolder(f, parent, getTranslation(), isOppositeStrand());
	}

	public Feature createFeature(Feature f, Feature.Template templ) 
	    throws ChangeVetoException
	{
	    throw new ChangeVetoException("Can't create features in this projection");
	}

	public void removeFeature(Feature f, Feature f2) 
	    throws ChangeVetoException
	{
	    throw new ChangeVetoException("Can't create features in this projection");
	}
    }


    private static class ProjectedOptimizedFeatureHolder extends AbstractFeatureHolder implements DASOptimizableFeatureHolder {
	private final DASOptimizableFeatureHolder wrapped;
	private final FeatureHolder parent;
	private final int translate;
	private boolean oppositeStrand;

	private MergeFeatureHolder mfh = null;
	private ChangeListener underlyingFeaturesChange;

	public ProjectedOptimizedFeatureHolder(DASOptimizableFeatureHolder fh,
					       FeatureHolder parent, 
					       int translation,
					       boolean oppositeStrand) 
	{
	    this.wrapped = fh;
	    this.parent = parent;
	    this.translate = translation;
	    this.oppositeStrand = oppositeStrand;

	    underlyingFeaturesChange = new ChangeListener() {
		    public void preChange(ChangeEvent e)
			throws ChangeVetoException 
		    {
			if (changeSupport != null) {
			    changeSupport.firePreChangeEvent(new ChangeEvent(this,
									     FeatureHolder.FEATURES,
									     e.getChange(),
									     e.getPrevious(),
									     e));
			}
		    }
		    
		    public void postChange(ChangeEvent e) {
			mfh = null; // Flush all the cached projections --
			// who knows what might have changed.
			
			// System.err.println("*** Flushing cache on optimized projection...");

			if (changeSupport != null) {
			    changeSupport.firePostChangeEvent(new ChangeEvent(this,
									      FeatureHolder.FEATURES,
									      e.getChange(),
									      e.getPrevious(),
									      e));
			}
		    }
		} ;

	    wrapped.addChangeListener(underlyingFeaturesChange, ChangeType.UNKNOWN);
	    
	}

	protected MergeFeatureHolder getProjectedFeatures() {
	    if (mfh == null) {
		try {
		    Set optimizableFilters = wrapped.getOptimizableFilters();
		    mfh = new MergeFeatureHolder();
		    for (Iterator i = optimizableFilters.iterator(); i.hasNext(); ) {
			FeatureFilter potFilter = (FeatureFilter) i.next();
			FeatureHolder potHolder = wrapped.getOptimizedSubset(potFilter);
			
			FeatureFilter projectedPotFilter = potFilter;
			// System.err.println("projecting for: " + potFilter);
			if (extractInterestingLocation(projectedPotFilter) != null) {
			    if (projectedPotFilter instanceof FeatureFilter.ContainedByLocation) {
				if (oppositeStrand) {
				    System.err.println("*** Warning: flipped projection, can't fixup!");
				    projectedPotFilter = FeatureFilter.all;
				} else {
				    Location loc = ((FeatureFilter.ContainedByLocation) projectedPotFilter).getLocation();
				    projectedPotFilter = new FeatureFilter.ContainedByLocation(loc.translate(translate));
				}
			    } else {
				System.err.println("*** Warning: complex location-filter, can't fixup!");
				projectedPotFilter = FeatureFilter.all;
			    }   
			}
			
			FeatureHolder projectedPotHolder = projectFeatureHolder(potHolder,
										parent,
										translate,
										oppositeStrand);
			mfh.addFeatureHolder(projectedPotHolder, projectedPotFilter);
		    }
		} catch (BioException bex) {
		    throw new BioRuntimeException(bex);
		} catch (ChangeVetoException cve) {
		    throw new BioError(cve, "Change to internal featureset vetoed!");
		}
	    }

	    return mfh;
	}

	public int countFeatures() {
	    return wrapped.countFeatures();
	}
	
	public Iterator features() {
	    return getProjectedFeatures().features();
	}
	
	public boolean containsFeature(Feature f) {
	    return getProjectedFeatures().containsFeature(f);
	}

	public FeatureHolder filter(FeatureFilter ff, boolean recurse) {
	    return getProjectedFeatures().filter(ff, recurse);
	}

	public Set getOptimizableFilters() {
	    Map mm = getProjectedFeatures().getMergeMap();
	    Set osf = new HashSet();
	    for (Iterator i = mm.values().iterator(); i.hasNext(); ) {
		osf.add(i.next());
	    }
	    
	    return osf;
	}

	public FeatureHolder getOptimizedSubset(FeatureFilter ff) 
	    throws BioException
	{
	    List ss = new ArrayList();
	    Map mm = getProjectedFeatures().getMergeMap();
	    for (Iterator i = mm.entrySet().iterator(); i.hasNext(); ) {
		Map.Entry me = (Map.Entry) i.next();
		FeatureHolder fh = (FeatureHolder) me.getKey();
		FeatureFilter tff = (FeatureFilter) me.getValue();
		if (tff.equals(ff)) {
		    ss.add(fh);
		}
	    }
	    
	    if (ss.size() == 0) {
		throw new BioException("No optimized subset matching: " + ff);
	    } else if (ss.size() == 1) {
		return (FeatureHolder) ss.get(0);
	    } else {
		MergeFeatureHolder mfh = new MergeFeatureHolder();
		for (Iterator i = ss.iterator(); i.hasNext(); ) {
		    try {
			mfh.addFeatureHolder((FeatureHolder) i.next());
		    } catch (ChangeVetoException cve) {
			throw new BioError(cve, "Change to internal featureset vetoed!");
		    }
		}
		return mfh;
	    }
	}
    }
}

/*
 *                    BioJava development code
 *
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public Licence.  This should
 * be distributed with the code.  If you do not have a copy,
 * see:
 *
 *      http://www.gnu.org/copyleft/lesser.html
 *
 * Copyright for this code is held jointly by the individual
 * authors.  These should be listed in @author doc comments.
 *
 * For more information on the BioJava project and its aims,
 * or to join the biojava-l mailing list, visit the home page
 * at:
 *
 *      http://www.biojava.org/
 *
 */

package org.biojava.bio.seq;

import java.util.*;
import java.lang.reflect.*;

import org.biojava.utils.*;
import org.biojava.utils.bytecode.*;
import org.biojava.bio.*;
import org.biojava.bio.seq.impl.*;
import org.biojava.bio.symbol.*;
import org.biojava.bio.program.das.*;

/**
 * Helper class for projecting Feature objects into an alternative
 * coordinate system.  This class offers a view onto a set of features,
 * projecting them into a different coordinate system, and also changing
 * their <code>parent</code> property.  The destination coordinate system
 * can run in the opposite direction from the source, in which case the
 * <code>strand</code> property of StrandedFeatures is flipped.
 *
 * <p>
 * The projected features returned by this class are small proxy objects.
 * Proxy classes are autogenerated on demand for any sub-interface of
 * <code>Feature</code>.  These <code>getLocation</code>, <code>getParent</code>,
 * <code>getSequence</code> and (where applicable) <code>getStrand</code> methods
 * of projected features may return different values from the underlying
 * feature.  All other methods are proxied directly.
 * </p>
 *
 * @author Thomas Down
 * @author Matthew Pocock
 * @since 1.1
 */

public class ProjectedFeatureHolder extends AbstractFeatureHolder {
    private final FeatureHolder wrapped;
    private final FeatureHolder parent;
    private final int translate;
    private FeatureHolder projectedFeatures;
    private boolean oppositeStrand;
    private boolean cachingProjections = true;

    private FeatureFilter filter;

    private ChangeListener underlyingFeaturesChange;


    private static Location extractInterestingLocation(FeatureFilter ff) {
	if (ff instanceof FeatureFilter.OverlapsLocation) {
	    return ((FeatureFilter.OverlapsLocation) ff).getLocation();
	} else if (ff instanceof FeatureFilter.ContainedByLocation) {
	    return ((FeatureFilter.ContainedByLocation) ff).getLocation();
	} else if (ff instanceof FeatureFilter.And) {
	    FeatureFilter.And ffa = (FeatureFilter.And) ff;
	    Location l1 = extractInterestingLocation(ffa.getChild1());
	    Location l2 = extractInterestingLocation(ffa.getChild2());

	    if (l1 != null) {
		if (l2 != null) {
		    return l1.intersection(l2);
		} else {
		    return l1;
		}
	    } else {
		if (l2 != null) {
		    return l2;
		} else {
		    return null;
		}
	    }
	}

	// Don't know how this filter relates to location.

	return null;
    }
    

    public static FeatureHolder projectFeatureHolder(FeatureHolder fh,
						     FeatureHolder parent, 
						     int translation,
						     boolean flip)
    {
	if (fh instanceof DASOptimizableFeatureHolder) {
	    return new ProjectedOptimizedFeatureHolder((DASOptimizableFeatureHolder) fh,
						       parent,
						       translation,
						       flip);
	} else {
	    return new ProjectedFeatureHolder(fh, parent, translation, flip);
	}    
    }

    /**
     * Construct a new FeatureHolder which projects a set of features
     * into a new coordinate system.  If <code>translation</code> is 0
     * and <code>oppositeStrand</code> is <code>false</code>, the features
     * are simply reparented without any transformation.
     *
     * @param fh The set of features to project.
     * @param filter A FeatureFilter to apply to the set of features before projection.
     * @param parent The FeatureHolder which is to act as parent
     *               for the projected features.
     * @param translation The translation to apply to map locations into
     *                    the projected coordinate system.  This is the point
     *                    in the destination coordinate system which is equivalent
     *                    to 0 in the source coordinate system.
     * @param oppositeStrand <code>true</code> if translating into the opposite coordinate system.
     *                       This alters the transformation applied to locations, and also flips
     *                       the <code>strand</code> property of StrandedFeatures.
     */

    public ProjectedFeatureHolder(FeatureHolder fh,
				  FeatureFilter filter,
				  FeatureHolder parent, 
				  int translation,
				  boolean oppositeStrand) 
    {
	// System.err.println("+++ Constructing a ProjectedFeatureHolder");
	// System.err.println("+++ Parent: " + fh.getClass().getName());
	// new Exception("How we got here...").printStackTrace();
	

	this.wrapped = fh;
	this.parent = parent;
	this.translate = translation;
	this.oppositeStrand = oppositeStrand;
	this.filter = filter;

	underlyingFeaturesChange = new ChangeListener() {
	    public void preChange(ChangeEvent e)
		throws ChangeVetoException 
	    {
		if (changeSupport != null) {
		    changeSupport.firePreChangeEvent(new ChangeEvent(this,
								     FeatureHolder.FEATURES,
								     e.getChange(),
								     e.getPrevious(),
								     e));
		}
	    }

	    public void postChange(ChangeEvent e) {
		projectedFeatures = null; // Flush all the cached projections --
		                          // who knows what might have changed.

		if (changeSupport != null) {
		    changeSupport.firePostChangeEvent(new ChangeEvent(this,
								      FeatureHolder.FEATURES,
								      e.getChange(),
								      e.getPrevious(),
								      e));
		}
	    }
	} ;

	wrapped.addChangeListener(underlyingFeaturesChange);
    }

    public boolean isCachingProjections() {
	return cachingProjections;
    }

    /**
     * Determine whether or not the projected features should be cached.
     * This is a temporary optimization, and might go away once feature
     * filtering is more intelligent.
     *
     * @since 1.2
     */

    public void setIsCachingProjections(boolean b) {
	cachingProjections = b;
	projectedFeatures = null;
    }

    /**
     * Construct a new FeatureHolder which projects a set of features
     * into a new coordinate system.  If <code>translation</code> is 0
     * and <code>oppositeStrand</code> is <code>false</code>, the features
     * are simply reparented without any transformation.
     *
     * @param fh The set of features to project.
     * @param parent The FeatureHolder which is to act as parent
     *               for the projected features.
     * @param translation The translation to apply to map locations into
     *                    the projected coordinate system.  This is the point
     *                    in the destination coordinate system which is equivalent
     *                    to 0 in the source coordinate system.
     * @param oppositeStrand <code>true</code> if translating into the opposite coordinate system.
     *                       This alters the transformation applied to locations, and also flips
     *                       the <code>strand</code> property of StrandedFeatures.
     */

    public ProjectedFeatureHolder(FeatureHolder fh,
				  FeatureHolder parent, 
				  int translation,
				  boolean oppositeStrand) 
    {
	this(fh, null, parent, translation, oppositeStrand);
    }

    protected FeatureHolder getProjectedFeatures() {
	if (projectedFeatures != null) {
	    return projectedFeatures;
	}

	FeatureHolder toProject = wrapped;
	if (filter != null) {
	    toProject = toProject.filter(filter, false);
	}

	SimpleFeatureHolder sfh = new SimpleFeatureHolder();
	for (Iterator i = toProject.features(); i.hasNext(); ) {
	    Feature f = (Feature) i.next();
	    Feature wf = projectFeature(f);
	    try {
		sfh.addFeature(wf);
	    } catch (ChangeVetoException cve) {
		throw new BioError(
				   cve,
				   "Assertion failure: Should be able to manipulate this FeatureHolder"
				   );
	    }
	}

	if (cachingProjections) {
	    projectedFeatures = sfh;
	}

	return sfh;
    }

    protected Feature projectFeature(Feature f) {
	Class featureClass = f.getClass();
	Class[] fcInterfaces = featureClass.getInterfaces();
	Class featureInterface = Feature.class;
	for (int i = fcInterfaces.length - 1; i >= 0; --i) {
	    if (Feature.class.isAssignableFrom(fcInterfaces[i])) {
		featureInterface = fcInterfaces[i];
		break;
	    }
	}

	Class projectionClass = getProjectionClass(featureInterface);
	Class[] sig = new Class[2];
	sig[0] = featureInterface;
	sig[1] = ProjectedFeatureHolder.class;
	try {
	    Constructor ct = projectionClass.getConstructor(sig);
	    Object[] args = new Object[2];
	    args[0] = f;
	    args[1] = this;
	    return (Feature) ct.newInstance(args);
	} catch (Exception ex) {
	    throw new BioError(ex, "Assertion failed: Couldn't instantiate proxy " + projectionClass.getName());
	}
    }

    public int countFeatures() {
	return wrapped.countFeatures();
    }

    public Iterator features() {
	return getProjectedFeatures().features();
    }
    
    public boolean containsFeature(Feature f) {
      return getProjectedFeatures().containsFeature(f);
    }

    public FeatureHolder filter(FeatureFilter ff, boolean recurse) {
	return getProjectedFeatures().filter(ff, recurse);
    }

    private static Map _projectionClasses;
    private static int seed = 1;
    private static GeneratedClassLoader loader;

    static {
	_projectionClasses = new HashMap();
	_projectionClasses.put(Feature.class, ProjectedFeatureWrapper.class);
	_projectionClasses.put(StrandedFeature.class, ProjectedStrandedFeatureWrapper.class);
	loader = new GeneratedClassLoader(ProjectedFeatureWrapper.class.getClassLoader());
    }

    private static Class getProjectionClass(Class face) {
	Class projection = (Class) _projectionClasses.get(face);
	if (projection == null) {
	    try {
		Class baseClass = ProjectedFeatureWrapper.class;
		if (StrandedFeature.class.isAssignableFrom(face))
		    baseClass = ProjectedStrandedFeatureWrapper.class;
		
		StringTokenizer st = new StringTokenizer(face.getName(), ".");
		String faceName = st.nextToken();
		while (st.hasMoreTokens())
		    faceName = st.nextToken();
		
		CodeClass baseClassC = IntrospectedCodeClass.forClass(baseClass);
		CodeClass faceClassC = IntrospectedCodeClass.forClass(face);

		GeneratedCodeClass pclass = new GeneratedCodeClass(
      "org.biojava.bio.seq.impl.Projection_" + faceName + "_" + (seed++),
			baseClassC,
		  new CodeClass[] { faceClassC },
			CodeUtils.ACC_PUBLIC | CodeUtils.ACC_SUPER
    );

		List baseInitArgsList = new ArrayList();
		baseInitArgsList.add(baseClass == ProjectedStrandedFeatureWrapper.class ?
				     IntrospectedCodeClass.forClass(StrandedFeature.class) :
				     IntrospectedCodeClass.forClass(Feature.class));
		baseInitArgsList.add(IntrospectedCodeClass.forClass(ProjectedFeatureHolder.class));
		CodeMethod m_ourBase_init = new SimpleCodeMethod("<init>",
								 baseClassC,
								 CodeUtils.TYPE_VOID,
								 baseInitArgsList,
								 CodeUtils.ACC_PUBLIC);
		CodeMethod m_ourBase_getViewedFeature = new SimpleCodeMethod("getViewedFeature",
									     baseClassC,
									     IntrospectedCodeClass.forClass(Feature.class),
									     new ArrayList(),
									     CodeUtils.ACC_PUBLIC);

		GeneratedCodeMethod init = pclass.createMethod("<init>",
							       IntrospectedCodeClass.forClass(Void.TYPE),
							       new CodeClass[] {
								   faceClassC,
								   IntrospectedCodeClass.forClass(
									     ProjectedFeatureHolder.class
									                         )},
							       CodeUtils.ACC_PUBLIC);
		InstructionVector iv = new InstructionVector();
		iv.add(ByteCode.make_aload(init.getThis()));
		iv.add(ByteCode.make_aload(init.getVariable(0)));
		iv.add(ByteCode.make_aload(init.getVariable(1)));
		iv.add(ByteCode.make_invokespecial(m_ourBase_init));
		iv.add(ByteCode.make_return());
		pclass.setCodeGenerator(init, iv);

		for (Iterator methIt = faceClassC.getMethods().iterator(); methIt.hasNext(); ) {
		    CodeMethod faceMethod = (CodeMethod) methIt.next();
		    if (baseClassC.getMethodsByName(faceMethod.getName()).size() > 0) {
			// System.err.println("Skipping defined method " + faceMethod.getName());
			continue;
		    }
		    
		    if (faceMethod.numParameters() > 0) {
			// System.err.println("Method " + faceMethod.getName() + " has params :|");
			continue;
		    }
		    
		    GeneratedCodeMethod proxyMethod = pclass.createMethod(faceMethod.getName(),
									  faceMethod.getReturnType(),
									  CodeUtils.EMPTY_LIST,
									  CodeUtils.ACC_PUBLIC);
		    iv = new InstructionVector();
		    iv.add(ByteCode.make_aload(proxyMethod.getThis()));
		    iv.add(ByteCode.make_invokevirtual(m_ourBase_getViewedFeature));
		    iv.add(ByteCode.make_invokeinterface(faceMethod));
		    Instruction returni = ByteCode.make_areturn();
		    CodeClass rtype = proxyMethod.getReturnType();
		    if (rtype == CodeUtils.TYPE_VOID) {
			returni = ByteCode.make_return();
		    } else if (rtype == CodeUtils.TYPE_INT ||
			       rtype == CodeUtils.TYPE_SHORT ||
			       rtype == CodeUtils.TYPE_CHAR ||
			       rtype == CodeUtils.TYPE_BYTE) {
			returni = ByteCode.make_ireturn();
		    } else if (rtype == CodeUtils.TYPE_LONG) {
			returni = ByteCode.make_lreturn();
		    } else if (rtype == CodeUtils.TYPE_FLOAT) {
			returni = ByteCode.make_freturn();
		    } else if (rtype == CodeUtils.TYPE_DOUBLE) {
			returni = ByteCode.make_dreturn();
		    }
		    iv.add(returni);
		    pclass.setCodeGenerator(proxyMethod, iv);
		}			
	
		projection = loader.defineClass(pclass);
		_projectionClasses.put(face, projection);
	    } catch (CodeException ex) {
		throw new BioError(ex);
	    }
							       
	}
	return projection;
    }

    public Location getProjectedLocation(Location oldLoc) {
	if (oppositeStrand) {
	    if (oldLoc.isContiguous()) {
		return new RangeLocation(translate - oldLoc.getMax(),
					 translate - oldLoc.getMin());
	    } else {
		Location compound = Location.empty;
		for (Iterator i = oldLoc.blockIterator(); i.hasNext(); ) {
		    Location oldBlock = (Location) i.next();
		    compound = compound.union(new RangeLocation(translate - oldBlock.getMax(),
								translate - oldBlock.getMin()));
		}
		return compound;
	    }
	} else {
	    return oldLoc.translate(translate);
	}
    }

    public int getTranslation() {
	return translate;
    }

    public boolean isOppositeStrand() {
	return oppositeStrand;
    }

    public FeatureHolder getParent() {
	return parent;
    }


    private static class ProjectedOptimizedFeatureHolder extends AbstractFeatureHolder implements DASOptimizableFeatureHolder {
	private final DASOptimizableFeatureHolder wrapped;
	private final FeatureHolder parent;
	private final int translate;
	private boolean oppositeStrand;

	private MergeFeatureHolder mfh = null;
	private ChangeListener underlyingFeaturesChange;

	public ProjectedOptimizedFeatureHolder(DASOptimizableFeatureHolder fh,
					       FeatureHolder parent, 
					       int translation,
					       boolean oppositeStrand) 
	{
	    this.wrapped = fh;
	    this.parent = parent;
	    this.translate = translation;
	    this.oppositeStrand = oppositeStrand;

	    underlyingFeaturesChange = new ChangeListener() {
		    public void preChange(ChangeEvent e)
			throws ChangeVetoException 
		    {
			if (changeSupport != null) {
			    changeSupport.firePreChangeEvent(new ChangeEvent(this,
									     FeatureHolder.FEATURES,
									     e.getChange(),
									     e.getPrevious(),
									     e));
			}
		    }
		    
		    public void postChange(ChangeEvent e) {
			mfh = null; // Flush all the cached projections --
			// who knows what might have changed.
			
			// System.err.println("*** Flushing cache on optimized projection...");

			if (changeSupport != null) {
			    changeSupport.firePostChangeEvent(new ChangeEvent(this,
									      FeatureHolder.FEATURES,
									      e.getChange(),
									      e.getPrevious(),
									      e));
			}
		    }
		} ;

	    wrapped.addChangeListener(underlyingFeaturesChange, ChangeType.UNKNOWN);
	    
	}

	protected MergeFeatureHolder getProjectedFeatures() {
	    if (mfh == null) {
		try {
		    Set optimizableFilters = wrapped.getOptimizableFilters();
		    mfh = new MergeFeatureHolder();
		    for (Iterator i = optimizableFilters.iterator(); i.hasNext(); ) {
			FeatureFilter potFilter = (FeatureFilter) i.next();
			FeatureHolder potHolder = wrapped.getOptimizedSubset(potFilter);
			
			FeatureFilter projectedPotFilter = potFilter;
			// System.err.println("projecting for: " + potFilter);
			if (extractInterestingLocation(projectedPotFilter) != null) {
			    if (projectedPotFilter instanceof FeatureFilter.ContainedByLocation) {
				if (oppositeStrand) {
				    System.err.println("*** Warning: flipped projection, can't fixup!");
				    projectedPotFilter = FeatureFilter.all;
				} else {
				    Location loc = ((FeatureFilter.ContainedByLocation) projectedPotFilter).getLocation();
				    projectedPotFilter = new FeatureFilter.ContainedByLocation(loc.translate(translate));
				}
			    } else {
				System.err.println("*** Warning: complex location-filter, can't fixup!");
				projectedPotFilter = FeatureFilter.all;
			    }   
			}
			
			FeatureHolder projectedPotHolder = projectFeatureHolder(potHolder,
										parent,
										translate,
										oppositeStrand);
			mfh.addFeatureHolder(projectedPotHolder, projectedPotFilter);
		    }
		} catch (BioException bex) {
		    throw new BioRuntimeException(bex);
		} catch (ChangeVetoException cve) {
		    throw new BioError(cve, "Change to internal featureset vetoed!");
		}
	    }

	    return mfh;
	}

	public int countFeatures() {
	    return wrapped.countFeatures();
	}
	
	public Iterator features() {
	    return getProjectedFeatures().features();
	}
	
	public boolean containsFeature(Feature f) {
	    return getProjectedFeatures().containsFeature(f);
	}

	public FeatureHolder filter(FeatureFilter ff, boolean recurse) {
	    return getProjectedFeatures().filter(ff, recurse);
	}

	public Set getOptimizableFilters() {
	    Map mm = getProjectedFeatures().getMergeMap();
	    Set osf = new HashSet();
	    for (Iterator i = mm.values().iterator(); i.hasNext(); ) {
		osf.add(i.next());
	    }
	    
	    return osf;
	}

	public FeatureHolder getOptimizedSubset(FeatureFilter ff) 
	    throws BioException
	{
	    List ss = new ArrayList();
	    Map mm = getProjectedFeatures().getMergeMap();
	    for (Iterator i = mm.entrySet().iterator(); i.hasNext(); ) {
		Map.Entry me = (Map.Entry) i.next();
		FeatureHolder fh = (FeatureHolder) me.getKey();
		FeatureFilter tff = (FeatureFilter) me.getValue();
		if (tff.equals(ff)) {
		    ss.add(fh);
		}
	    }
	    
	    if (ss.size() == 0) {
		throw new BioException("No optimized subset matching: " + ff);
	    } else if (ss.size() == 1) {
		return (FeatureHolder) ss.get(0);
	    } else {
		MergeFeatureHolder mfh = new MergeFeatureHolder();
		for (Iterator i = ss.iterator(); i.hasNext(); ) {
		    try {
			mfh.addFeatureHolder((FeatureHolder) i.next());
		    } catch (ChangeVetoException cve) {
			throw new BioError(cve, "Change to internal featureset vetoed!");
		    }
		}
		return mfh;
	    }
	}
    }
}

/*
 *                    BioJava development code
 *
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public Licence.  This should
 * be distributed with the code.  If you do not have a copy,
 * see:
 *
 *      http://www.gnu.org/copyleft/lesser.html
 *
 * Copyright for this code is held jointly by the individual
 * authors.  These should be listed in @author doc comments.
 *
 * For more information on the BioJava project and its aims,
 * or to join the biojava-l mailing list, visit the home page
 * at:
 *
 *      http://www.biojava.org/
 *
 */
 
package org.biojava.bio.seq;

import java.util.*;
import java.lang.reflect.*;

import org.biojava.utils.*;
import org.biojava.bio.*;
import org.biojava.bio.seq.impl.*;
import org.biojava.bio.seq.projection.*;
import org.biojava.bio.symbol.*;

/**
 * Helper class for projecting Feature objects into an alternative
 * coordinate system.  This class offers a view onto a set of features,
 * projecting them into a different coordinate system, and also changing
 * their <code>parent</code> property.  The destination coordinate system
 * can run in the opposite direction from the source, in which case the
 * <code>strand</code> property of StrandedFeatures is flipped.
 *
 * <p>
 * The projected features returned by this class are small proxy objects.
 * Proxy classes are autogenerated on demand for any sub-interface of
 * <code>Feature</code>.  These <code>getLocation</code>, <code>getParent</code>,
 * <code>getSequence</code> and (where applicable) <code>getStrand</code> methods
 * of projected features may return different values from the underlying
 * feature.  All other methods are proxied directly.
 * </p>
 *
 * <p>
 * Originally, <code>ProjectedFeatureHolder</code> was a self-contained
 * class containing the full projection infrastructure.  Since BioJava
 * 1.2, most of the projection infrastructure has been moved to separate
 * classes in the package <code>org.biojava.bio.seq.projection</code>.
 * Custom applications may wish to use that code directly.
 * </p>
 *
 * @author Thomas Down
 * @author Matthew Pocock
 * @since 1.1
 */

public class ProjectedFeatureHolder extends AbstractFeatureHolder implements FeatureHolder, ProjectionContext {
    private final FeatureHolder wrapped;
    private final FeatureHolder parent;
    private final int translate;
    private final boolean oppositeStrand;
    private ChangeListener underlyingFeaturesChange;
    private Map forwardersByFeature = new HashMap();
    private ProjectionSet topLevelFeatures;

    public static FeatureHolder projectFeatureHolder(FeatureHolder fh,
						                             FeatureHolder parent, 
                                                     int translation,
                                                     boolean flip)
    {
	    return new ProjectedFeatureHolder(fh, parent, translation, flip);
    }

    /**
     * Construct a new FeatureHolder which projects a set of features
     * into a new coordinate system.  If <code>translation</code> is 0
     * and <code>oppositeStrand</code> is <code>false</code>, the features
     * are simply reparented without any transformation.
     *
     * @param fh The set of features to project.
     * @param filter A FeatureFilter to apply to the set of features before projection.
     * @param parent The FeatureHolder which is to act as parent
     *               for the projected features.
     * @param translation The translation to apply to map locations into
     *                    the projected coordinate system.  This is the point
     *                    in the destination coordinate system which is equivalent
     *                    to 0 in the source coordinate system.
     * @param oppositeStrand <code>true</code> if translating into the opposite coordinate system.
     *                       This alters the transformation applied to locations, and also flips
     *                       the <code>strand</code> property of StrandedFeatures.
     */

    public ProjectedFeatureHolder(FeatureHolder fh,
				                  FeatureFilter filter,
                                  FeatureHolder parent, 
                                  int translation,
                                  boolean oppositeStrand) 
    {
        this(new LazyFilterFeatureHolder(fh, filter),
             parent,
             translation,
             oppositeStrand);
    }

    /**
     * Construct a new FeatureHolder which projects a set of features
     * into a new coordinate system.  If <code>translation</code> is 0
     * and <code>oppositeStrand</code> is <code>false</code>, the features
     * are simply reparented without any transformation.
     *
     * @param fh The set of features to project.
     * @param parent The FeatureHolder which is to act as parent
     *               for the projected features.
     * @param translation The translation to apply to map locations into
     *                    the projected coordinate system.  This is the point
     *                    in the destination coordinate system which is equivalent
     *                    to 0 in the source coordinate system.
     * @param oppositeStrand <code>true</code> if translating into the opposite coordinate system.
     *                       This alters the transformation applied to locations, and also flips
     *                       the <code>strand</code> property of StrandedFeatures.
     */

    public ProjectedFeatureHolder(FeatureHolder fh,
				                  FeatureHolder parent, 
                                  int translation,
                                  boolean oppositeStrand) 
    {
        this.wrapped = fh;
        this.parent = parent;
        this.translate = translation;
        this.oppositeStrand = oppositeStrand;

        this.topLevelFeatures = new ProjectionSet(wrapped);

        underlyingFeaturesChange = new ChangeListener() {
            public void preChange(ChangeEvent e)
                throws ChangeVetoException 
            {
                if (hasListeners()) {
                    getChangeSupport(FeatureHolder.FEATURES).firePreChangeEvent(forwardChangeEvent(e));
                }
            }

            public void postChange(ChangeEvent e) {
               if (hasListeners()) {
                   getChangeSupport(FeatureHolder.FEATURES).firePostChangeEvent(forwardChangeEvent(e));
               }
            }
        } ;

        wrapped.addChangeListener(underlyingFeaturesChange);
    }
    
    //
    // Normal FeatureHolder methods get delegated to our top-level ProjectionSet
    //
    
    public Iterator features() {
        return topLevelFeatures.features();
    }
    
    public int countFeatures() {
        return topLevelFeatures.countFeatures();
    }
    
    public boolean containsFeature(Feature f) {
        return topLevelFeatures.containsFeature(f);
    }
    
    public FeatureHolder filter(FeatureFilter ff) {
        return topLevelFeatures.filter(ff);
    }
    
    public FeatureHolder filter(FeatureFilter ff, boolean recurse) {
        return topLevelFeatures.filter(ff, recurse);
    }
    
    public Feature createFeature(Feature.Template templ) 
	        throws ChangeVetoException
    {
        throw new ChangeVetoException("Can't create features in this projection");
    }

    public void removeFeature(Feature f) 
        throws ChangeVetoException
	{
        throw new ChangeVetoException("Can't create features in this projection");
	}
    
    //
    // Dumb set of features to which we delegate everything except the
    // ChangeEvent stuff.
    //
    
    private class ProjectionSet implements FeatureHolder {
        private final FeatureHolder baseSet;
        
        ProjectionSet(FeatureHolder baseSet) {
            this.baseSet = baseSet;
        }
        
        public int countFeatures() {
            return baseSet.countFeatures();
        }

        public Iterator features() {
            final Iterator wrappedIterator = baseSet.features();
            return new Iterator() {
                public boolean hasNext() {
                    return wrappedIterator.hasNext();
                }
            
                public Object next() {
                    return projectFeature((Feature) wrappedIterator.next());
                }
            
                public void remove() {
                    throw new UnsupportedOperationException();
                }
            } ;
        }
    
        public boolean containsFeature(Feature f) {
            for (Iterator fi = features(); fi.hasNext(); ) {
                if (f.equals(fi.next())) {
                    return true;
                }
            }
            return false;
        }

        public FeatureHolder filter(FeatureFilter ff) {
            return filter(ff, true); // bit of a hack for now.
        }
    
        public FeatureHolder filter(FeatureFilter ff, boolean recurse) {
            ff = transformFilter(ff);
            FeatureHolder toProject = baseSet.filter(ff, recurse);
            return new ProjectionSet(toProject);
        }
    
        public Feature createFeature(Feature.Template templ) 
	        throws ChangeVetoException
        {
            throw new ChangeVetoException("Can't create features in this projection");
        }

        public void removeFeature(Feature f) 
                throws ChangeVetoException
	    {
	        throw new ChangeVetoException("Can't create features in this projection");
	    }
        
        public void addChangeListener(ChangeListener cl) {}
        public void removeChangeListener(ChangeListener cl) {}
        public void addChangeListener(ChangeListener cl, ChangeType ct) {}
        public void removeChangeListener(ChangeListener cl, ChangeType ct) {}
        public boolean isUnchanging(ChangeType ct) { return true; }
    }
    
    private FeatureFilter transformFilter(FeatureFilter ff) {
        return FilterUtils.transformFilter(
            ff,
            new FilterUtils.FilterTransformer() {
                public FeatureFilter transform(FeatureFilter ff) {
                    if (ff instanceof FeatureFilter.OverlapsLocation) {
                        return new FeatureFilter.OverlapsLocation(untransformLocation(((FeatureFilter.OverlapsLocation) ff).getLocation()));
                    } else if (ff instanceof FeatureFilter.ContainedByLocation) {
                        return new FeatureFilter.ContainedByLocation(untransformLocation(((FeatureFilter.ContainedByLocation) ff).getLocation()));
                    } else if (ff instanceof FeatureFilter.StrandFilter) {
                        return new FeatureFilter.StrandFilter(transformStrand(((FeatureFilter.StrandFilter) ff).getStrand()));
                    } else {
                        return ff;
                    }
                }   
            }
        ) ;
    }
    
    protected StrandedFeature.Strand transformStrand(StrandedFeature.Strand strand) {
        if (oppositeStrand) {
            return strand.flip();
        } else {
            return strand;
        }
    }
    
    protected Location transformLocation(Location oldLoc) {
        return ProjectionUtils.transformLocation(oldLoc, translate, oppositeStrand);
    }
    
    protected Location untransformLocation(Location oldLoc) {
        if (oppositeStrand) {
            if (oldLoc.isContiguous()) {
                if (oldLoc instanceof PointLocation){
                    return new PointLocation(translate - oldLoc.getMin());
                } else {
                    return new RangeLocation(translate - oldLoc.getMax(),
    	                                     translate - oldLoc.getMin());
                }
            } else {
                Location compound = Location.empty;
                List locList = new ArrayList();
                for (Iterator i = oldLoc.blockIterator(); i.hasNext(); ) {
                    Location oldBlock = (Location) i.next();
                    locList.add(new RangeLocation(translate - oldBlock.getMax(),
                    		      			translate - oldBlock.getMin()));
                }
                compound = LocationTools.union(locList);
                return compound;
            }
        } else {
            return oldLoc.translate(-translate);
        }
    }
    
    /**
     * Create a single projected feature using the rules of this <code>ProjectedFeatureHolder</code>.
     */
    
    public Feature projectFeature(Feature f) {
        return ProjectionEngine.DEFAULT.projectFeature(f, this);
    }

    /**
     * Return the translation component of the transformation applied by this FeatureHolder
     */
    
    public int getTranslation() {
        return translate;
    }

    /**
     * Return true if projected features should be flipped to the opposite strand
     */
    
    public boolean isOppositeStrand() {
        return oppositeStrand;
    }

    /**
     * Return the parent of all top-level features in this FeatureHolder.
     */
    
    public FeatureHolder getParent() {
        return parent;
    }
    
    
    //
    // The following methods are our implementation of ProjectionContext
    //
    
        public FeatureHolder getParent(Feature f) {
            FeatureHolder oldP = f.getParent();
            if (oldP instanceof Feature) {
                if (wrapped.containsFeature(f)) {
                    return parent;
                } else {
                    return projectFeature((Feature) oldP);
                }
            } else {
                return parent;
            }
        }	    

        public Sequence getSequence(Feature f) {
            FeatureHolder fh = parent;
            while (fh instanceof Feature) {
                fh = ((Feature) fh).getParent();
            }
            return (Sequence) fh;
        }

        public Location getLocation(Feature f) {
            Location oldLoc = f.getLocation();
            return transformLocation(oldLoc);
        }

        public StrandedFeature.Strand getStrand(StrandedFeature sf) {
            StrandedFeature.Strand s = sf.getStrand();
            return transformStrand(s);
        }

        public Annotation getAnnotation(Feature f) {
            return f.getAnnotation();
        }

        public FeatureHolder projectChildFeatures(Feature f, FeatureHolder parent) {
            return new ProjectionSet(f);
        }

        public Feature createFeature(Feature f, Feature.Template templ) 
	        throws ChangeVetoException
        {
            throw new ChangeVetoException("Can't create features in this projection");
        }

        public void removeFeature(Feature f, Feature f2) 
                throws ChangeVetoException
	    {
	        throw new ChangeVetoException("Can't create features in this projection");
	    }
        
    //
    // Event wiring stuff
    //    
        
    public void addChangeListener(Feature f, ChangeListener cl, ChangeType ct) {
        if (!f.isUnchanging(ct)) {
            PFChangeForwarder forwarder = (PFChangeForwarder) forwardersByFeature.get(f);
            if (forwarder == null) {
                forwarder = new PFChangeForwarder(f);
                forwardersByFeature.put(f, forwarder);
                f.addChangeListener(forwarder, ChangeType.UNKNOWN);
            }
            forwarder.addChangeListener(cl, ct);
        }
    }
        
    public void removeChangeListener(Feature f, ChangeListener cl, ChangeType ct) {
        PFChangeForwarder forwarder = (PFChangeForwarder) forwardersByFeature.get(f);
        if (forwarder != null) {
            forwarder.removeChangeListener(cl, ct);
            if (!forwarder.hasListeners()) {
                forwardersByFeature.remove(f);
                f.removeChangeListener(forwarder, ChangeType.UNKNOWN);
            }
        }
    }
    
    private class PFChangeForwarder extends ChangeSupport implements ChangeListener {
        private Feature master;
        
        public PFChangeForwarder(Feature master) {
            super(1);
            this.master = master;
        }
        
        public void preChange(ChangeEvent cev)
            throws ChangeVetoException
        {
            ChangeEvent cev2 = forwardFeatureChangeEvent(master, cev);
            if (cev2 != null) {
                firePreChangeEvent(cev2);
            }
        }
        
        public void postChange(ChangeEvent cev) {
            ChangeEvent cev2 = forwardFeatureChangeEvent(master, cev);
            if (cev2 != null) {
                firePostChangeEvent(cev2);
            }
        }
    }
        
    /**
     * Called internally to generate a forwarded version of a ChangeEvent from a ProjectedFeature
     */
        
    protected ChangeEvent forwardFeatureChangeEvent(Feature f, ChangeEvent cev) {
        return new ChangeEvent(projectFeature(f),
                               cev.getType(),
                               cev.getChange(),
                               cev.getPrevious(),
                               cev);
    }
    
    /**
     * Called internally to generate a forwarded version of a ChangeEvent from our
     * underlying FeatureHolder
     */
        
    protected ChangeEvent forwardChangeEvent(ChangeEvent cev) {
        return new ChangeEvent(this,
                               cev.getType(),
                               cev.getChange(),
                               cev.getPrevious(),
                               cev);
    }
}

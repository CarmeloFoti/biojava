/*
 *                    BioJava development code
 *
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public Licence.  This should
 * be distributed with the code.  If you do not have a copy,
 * see:
 *
 *      http://www.gnu.org/copyleft/lesser.html
 *
 * Copyright for this code is held jointly by the individual
 * authors.  These should be listed in @author doc comments.
 *
 * For more information on the BioJava project and its aims,
 * or to join the biojava-l mailing list, visit the home page
 * at:
 *
 *      http://www.biojava.org/
 *
 */

package org.biojava.bio.seq;

import java.util.*;
import java.lang.reflect.*;

import org.biojava.utils.*;
import org.biojava.utils.bytecode.*;
import org.biojava.bio.*;
import org.biojava.bio.seq.impl.*;
import org.biojava.bio.symbol.*;

/**
 * Helper class for projecting Feature objects into an alternative
 * coordinate system.  This class offers a view onto a set of features,
 * projecting them into a different coordinate system, and also changing
 * their <code>parent</code> property.  The destination coordinate system
 * can run in the opposite direction from the source, in which case the
 * <code>strand</code> property of StrandedFeatures is flipped.
 *
 * <p>
 * The projected features returned by this class are small proxy objects.
 * Proxy classes are autogenerated on demand for any sub-interface of
 * <code>Feature</code>.  These <code>getLocation</code>, <code>getParent</code>,
 * <code>getSequence</code> and (where applicable) <code>getStrand</code> methods
 * of projected features may return different values from the underlying
 * feature.  All other methods are proxied directly.
 * </p>
 *
 * @author Thomas Down
 * @since 1.1
 */

public class ProjectedFeatureHolder extends AbstractFeatureHolder {
    private final FeatureHolder wrapped;
    private final FeatureHolder parent;
    private final int translate;
    private FeatureHolder projectedFeatures;
    private boolean oppositeStrand;

    private ChangeListener underlyingFeaturesChange;

    /**
     * Construct a new FeatureHolder which projects a set of features
     * into a new coordinate system.  If <code>translation</code> is 0
     * and <code>oppositeStrand</code> is <code>false</code>, the features
     * are simply reparented without any transformation.
     *
     * @param fh The set of features to project.
     * @param parent The FeatureHolder which is to act as parent
     *               for the projected features.
     * @param translation The translation to apply to map locations into
     *                    the projected coordinate system.  This is the point
     *                    in the destination coordinate system which is equivalent
     *                    to 0 in the source coordinate system.
     * @param oppositeStrand <code>true</code> if translating into the opposite coordinate system.
     *                       This alters the transformation applied to locations, and also flips
     *                       the <code>strand</code> property of StrandedFeatures.
     */

    public ProjectedFeatureHolder(FeatureHolder fh, 
				  FeatureHolder parent, 
				  int translation,
				  boolean oppositeStrand) 
    {
	this.wrapped = fh;
	this.parent = parent;
	this.translate = translation;
	this.oppositeStrand = oppositeStrand;

	underlyingFeaturesChange = new ChangeListener() {
	    public void preChange(ChangeEvent e)
		throws ChangeVetoException 
	    {
		if (changeSupport != null) {
		    changeSupport.firePreChangeEvent(new ChangeEvent(this,
								     FeatureHolder.FEATURES,
								     e.getChange(),
								     e.getPrevious(),
								     e));
		}
	    }

	    public void postChange(ChangeEvent e) {
		projectedFeatures = null; // Flush all the cached projections --
		                          // who knows what might have changed.

		if (changeSupport != null) {
		    changeSupport.firePostChangeEvent(new ChangeEvent(this,
								      FeatureHolder.FEATURES,
								      e.getChange(),
								      e.getPrevious(),
								      e));
		}
	    }
	} ;

	wrapped.addChangeListener(underlyingFeaturesChange, FeatureHolder.FEATURES);
    }

    protected FeatureHolder getProjectedFeatures() {
	if (projectedFeatures == null) {
	    SimpleFeatureHolder sfh = new SimpleFeatureHolder();
	    for (Iterator i = wrapped.features(); i.hasNext(); ) {
		Feature f = (Feature) i.next();
		Feature wf = projectFeature(f);
		try {
		    sfh.addFeature(wf);
		} catch (ChangeVetoException cve) {
		    throw new BioError(
				       cve,
			     "Assertion failure: Should be able to manipulate this FeatureHolder"
				       );
		}
	    }
	    projectedFeatures = sfh;
	}
	return projectedFeatures;
    }

    protected Feature projectFeature(Feature f) {
	Class featureClass = f.getClass();
	Class[] fcInterfaces = featureClass.getInterfaces();
	Class featureInterface = Feature.class;
	for (int i = fcInterfaces.length - 1; i >= 0; --i) {
	    if (Feature.class.isAssignableFrom(fcInterfaces[i])) {
		featureInterface = fcInterfaces[i];
		break;
	    }
	}

	Class projectionClass = getProjectionClass(featureInterface);
	Class[] sig = new Class[2];
	sig[0] = featureInterface;
	sig[1] = ProjectedFeatureHolder.class;
	try {
	    Constructor ct = projectionClass.getConstructor(sig);
	    Object[] args = new Object[2];
	    args[0] = f;
	    args[1] = this;
	    return (Feature) ct.newInstance(args);
	} catch (Exception ex) {
	    throw new BioError(ex, "Assertion failed: Couldn't instantiate proxy " + projectionClass.getName());
	}
    }

    public int countFeatures() {
	return wrapped.countFeatures();
    }

    public Iterator features() {
	return getProjectedFeatures().features();
    }

    public FeatureHolder filter(FeatureFilter ff, boolean recurse) {
	return getProjectedFeatures().filter(ff, recurse);
    }

    private static Map _projectionClasses;
    private static int seed = 1;
    private static GeneratedClassLoader loader;

    static {
	_projectionClasses = new HashMap();
	_projectionClasses.put(Feature.class, ProjectedFeatureWrapper.class);
	_projectionClasses.put(StrandedFeature.class, ProjectedStrandedFeatureWrapper.class);
	loader = new GeneratedClassLoader(ProjectedFeatureWrapper.class.getClassLoader());
    }

    private static Class getProjectionClass(Class face) {
	Class projection = (Class) _projectionClasses.get(face);
	if (projection == null) {
	    try {
		Class baseClass = ProjectedFeatureWrapper.class;
		if (StrandedFeature.class.isAssignableFrom(face))
		    baseClass = ProjectedStrandedFeatureWrapper.class;
		
		StringTokenizer st = new StringTokenizer(face.getName(), ".");
		String faceName = st.nextToken();
		while (st.hasMoreTokens())
		    faceName = st.nextToken();
		
		CodeClass baseClassC = IntrospectedCodeClass.forClass(baseClass);
		CodeClass faceClassC = IntrospectedCodeClass.forClass(face);

		GeneratedCodeClass pclass = new GeneratedCodeClass(
      "org.biojava.bio.seq.impl.Projection_" + faceName + "_" + (seed++),
			baseClassC,
		  new CodeClass[] { faceClassC },
			CodeUtils.ACC_PUBLIC | CodeUtils.ACC_SUPER
    );

		List baseInitArgsList = new ArrayList();
		baseInitArgsList.add(baseClass == ProjectedStrandedFeatureWrapper.class ?
				     IntrospectedCodeClass.forClass(StrandedFeature.class) :
				     IntrospectedCodeClass.forClass(Feature.class));
		baseInitArgsList.add(IntrospectedCodeClass.forClass(ProjectedFeatureHolder.class));
		CodeMethod m_ourBase_init = new SimpleCodeMethod("<init>",
								 baseClassC,
								 CodeUtils.TYPE_VOID,
								 baseInitArgsList,
								 CodeUtils.ACC_PUBLIC);
		CodeMethod m_ourBase_getViewedFeature = new SimpleCodeMethod("getViewedFeature",
									     baseClassC,
									     IntrospectedCodeClass.forClass(Feature.class),
									     new ArrayList(),
									     CodeUtils.ACC_PUBLIC);

		GeneratedCodeMethod init = pclass.createMethod("<init>",
							       IntrospectedCodeClass.forClass(Void.TYPE),
							       new CodeClass[] {
                       faceClassC,
                       IntrospectedCodeClass.forClass(
                         ProjectedFeatureHolder.class
                       )
                     },
							       CodeUtils.ACC_PUBLIC);
		InstructionVector iv = new InstructionVector();
		iv.add(ByteCode.make_aload(init.getThis()));
		iv.add(ByteCode.make_aload(init.getVariable(0)));
		iv.add(ByteCode.make_aload(init.getVariable(1)));
		iv.add(ByteCode.make_invokespecial(m_ourBase_init));
		iv.add(ByteCode.make_return());
		pclass.setCodeGenerator(init, iv);

		for (Iterator methIt = faceClassC.getMethods().iterator(); methIt.hasNext(); ) {
		    CodeMethod faceMethod = (CodeMethod) methIt.next();
		    if (baseClassC.getMethodsByName(faceMethod.getName()).size() > 0) {
			// System.err.println("Skipping defined method " + faceMethod.getName());
			continue;
		    }
		    
		    if (faceMethod.numParameters() > 0) {
			// System.err.println("Method " + faceMethod.getName() + " has params :|");
			continue;
		    }
		    
		    GeneratedCodeMethod proxyMethod = pclass.createMethod(faceMethod.getName(),
									  faceMethod.getReturnType(),
									  CodeUtils.EMPTY_LIST,
									  CodeUtils.ACC_PUBLIC);
		    iv = new InstructionVector();
		    iv.add(ByteCode.make_aload(proxyMethod.getThis()));
		    iv.add(ByteCode.make_invokevirtual(m_ourBase_getViewedFeature));
		    iv.add(ByteCode.make_invokeinterface(faceMethod));
		    Instruction returni = ByteCode.make_areturn();
		    CodeClass rtype = proxyMethod.getReturnType();
		    if (rtype == CodeUtils.TYPE_VOID) {
			returni = ByteCode.make_return();
		    } else if (rtype == CodeUtils.TYPE_INT ||
			       rtype == CodeUtils.TYPE_SHORT ||
			       rtype == CodeUtils.TYPE_CHAR ||
			       rtype == CodeUtils.TYPE_BYTE) {
			returni = ByteCode.make_ireturn();
		    } else if (rtype == CodeUtils.TYPE_LONG) {
			returni = ByteCode.make_lreturn();
		    } else if (rtype == CodeUtils.TYPE_FLOAT) {
			returni = ByteCode.make_freturn();
		    } else if (rtype == CodeUtils.TYPE_DOUBLE) {
			returni = ByteCode.make_dreturn();
		    }
		    iv.add(returni);
		    pclass.setCodeGenerator(proxyMethod, iv);
		}			
	
		projection = loader.defineClass(pclass);
		_projectionClasses.put(face, projection);
	    } catch (CodeException ex) {
		throw new BioError(ex);
	    }
							       
	}
	return projection;
    }

    public Location getProjectedLocation(Location oldLoc) {
	if (oppositeStrand) {
	    if (oldLoc.isContiguous()) {
		return new RangeLocation(translate - oldLoc.getMax(),
					 translate - oldLoc.getMin());
	    } else {
		Location compound = Location.empty;
		for (Iterator i = oldLoc.blockIterator(); i.hasNext(); ) {
		    Location oldBlock = (Location) i.next();
		    compound = compound.union(new RangeLocation(translate - oldLoc.getMax(),
								translate - oldLoc.getMin()));
		}
		return compound;
	    }
	} else {
	    return oldLoc.translate(translate);
	}
    }

    public int getTranslation() {
	return translate;
    }

    public boolean isOppositeStrand() {
	return oppositeStrand;
    }

    public FeatureHolder getParent() {
	return parent;
    }
}

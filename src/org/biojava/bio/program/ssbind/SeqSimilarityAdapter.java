/*
 *                    BioJava development code
 *
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public Licence.  This should
 * be distributed with the code.  If you do not have a copy,
 * see:
 *
 *      http://www.gnu.org/copyleft/lesser.html
 *
 * Copyright for this code is held jointly by the individual
 * authors.  These should be listed in @author doc comments.
 *
 * For more information on the BioJava project and its aims,
 * or to join the biojava-l mailing list, visit the home page
 * at:
 *
 *      http://www.biojava.org/
 *
 */

package org.biojava.bio.program.ssbind;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.xml.sax.Attributes;
import org.xml.sax.ContentHandler;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;

import org.biojava.bio.search.SearchContentHandler;
import org.biojava.bio.search.SeqSimilaritySearchHit;
import org.biojava.bio.search.SeqSimilaritySearchResult;
import org.biojava.bio.search.SeqSimilaritySearchSubHit;
import org.biojava.bio.search.SequenceDBSearchSubHit;
import org.biojava.bio.seq.StrandedFeature.Strand;
import org.biojava.bio.seq.StrandedFeature;
import org.biojava.bio.symbol.SimpleAlignment;

/**
 * A <code>SeqSimilarityAdapter</code> converts SAX events into method
 * calls on a <code>SearchContentHandler</code> implementation. The
 * SAX events should describe elements conforming to the BioJava
 * BlastLikeDataSetCollection DTD. A
 * <code>BlastLikeSearchBuilder</code> is supplied, implementing the
 * <code>SearchContentHandler</code> interface, which will create
 * <code>SeqSimilaritySearchResult</code>s from the stream.
 *
 * @author <a href="mailto:kdj@sanger.ac.uk">Keith James</a>
 * @since 1.2
 */
public class SeqSimilarityAdapter extends DefaultHandler
{
    // An empty/debugging handler
    private static final ContentHandler empty = new DefaultHandler();

    // SAX ContentHandler factories
    private static Map hFactories = new HashMap();
    // Acceptable element contexts
    private static Map hContext = new HashMap();

    // Stack of handler bindings
    private List bStack;
    // The currently operating binding
    private HandlerBinding currentBinding;

    // The name of the program which generated the results
    private String program = "unknown";

    static
    {
        // Associate SAX ContentHandler factories with elements
        hFactories.put("BlastLikeDataSet", DataSetHandler.DATASET_HANDLER_FACTORY);
        hFactories.put("RawOutput",        BlastDBQueryHandler.BLAST_DBQUERY_HANDLER_FACTORY);
        hFactories.put("DatabaseId",       DatabaseIdHandler.DATABASE_ID_HANDLER_FACTORY);
        hFactories.put("QueryId",          QueryIdHandler.QUERY_ID_HANDLER_FACTORY);
        hFactories.put("Hit",              HitHandler.HIT_HANDLER_FACTORY);
        hFactories.put("HitId",            HitIdHandler.HIT_ID_HANDLER_FACTORY);
        hFactories.put("HitDescription",   HitDescHandler.HIT_DESC_HANDLER_FACTORY);
        hFactories.put("HSPSummary",       SubHitSummaryHandler.SUBHIT_SUMMARY_HANDLER_FACTORY);
        hFactories.put("QuerySequence",    AlignmentHandler.ALIGNMENT_HANDLER_FACTORY);
        hFactories.put("HitSequence",      AlignmentHandler.ALIGNMENT_HANDLER_FACTORY);

        // For elements which occur in more than one context, specify
        // which context we are interested in:

        // RawOutput only within Header
        hContext.put("RawOutput",      "Header");
        // HitId only within Hit
        hContext.put("HitId",          "Hit");
        // HitDescription only within Hit
        hContext.put("HitDescription", "Hit");
    }

    /**
     * The target handler
     */
    SearchContentHandler scHandler;

    /**
     * Creates a new <code>SeqSimilarityAdapter</code> object with an
     * empty handler stack.
     */
    public SeqSimilarityAdapter()
    {
        bStack = new ArrayList();
    }

    /**
     * <code>getSearchContentHandler</code> gets the handler which
     * will recieve the method calls generated by the adapter.
     *
     * @return a <code>SearchContentHandler</code>.
     */
    public SearchContentHandler getSearchContentHandler()
    {
        return scHandler;
    }

    /**
     * <code>setSearchContentHandler</code> sets the handler which
     * will recieve the method calls generated by the adapter.
     *
     * @param scHandler a <code>SearchContentHandler</code>.
     */
    public void setSearchContentHandler(final SearchContentHandler scHandler)
    {
        this.scHandler = scHandler;
    }

    /**
     * <code>startElement</code> notifies of the start of an element.
     *
     * @param uri a <code>String</code>.
     * @param localName a <code>String</code>.
     * @param qName a <code>String</code>.
     * @param attr an <code>Attributes</code> object.
     *
     * @exception SAXException if an error occurs.
     */
    public void startElement(String     uri,
                             String     localName,
                             String     qName,
                             Attributes attr)
        throws SAXException
    {
        // Callbacks to SearchContentHandler interface
        if (localName.equals("HSP"))
            scHandler.startSubHit();
        else if (localName.equals("Hit"))
            scHandler.startHit();
        else if (localName.equals("BlastLikeDataSet"))
            scHandler.startSearch();
        else if (localName.equals("BlastLikeDataSetCollection"))
            scHandler.setMoreSearches(true);

        // Check for a specific handler and element context
        if (hFactories.containsKey(localName) && inContext(localName))
        {
            ContentHandler handler = ((SSPropHandlerFactory) hFactories
                                      .get(localName)).getHandler(this);

            // Make a new handler binding
            currentBinding = new HandlerBinding(localName, handler);
        }
        else
        {
            // Make a binding to the empty handler
            currentBinding = new HandlerBinding(localName, empty);
        }

        currentBinding.handler.startElement(uri, localName, qName, attr);
        bStack.add(currentBinding);
    }

    /**
     * <code>endElement</code> notifies of the end of an element.
     *
     * @param uri a <code>String</code>.
     * @param localName a <code>String</code>.
     * @param qName a <code>String</code>.
     *
     * @exception SAXException if an error occurs.
     */
    public void endElement(String uri,
                           String localName,
                           String qName)
        throws SAXException
    {
        // Pop the current binding from the stack
        currentBinding = (HandlerBinding) bStack.remove(bStack.size() - 1);
        currentBinding.handler.endElement(uri, localName, qName);

        // Callbacks to SearchContentHandler interface
        if (localName.equals("HSP"))
            scHandler.endSubHit();
        else if (localName.equals("Hit"))
            scHandler.endHit();
        else if (localName.equals("BlastLikeDataSet"))
            scHandler.endSearch();
        else if (localName.equals("BlastLikeDataSetCollection"))
            scHandler.setMoreSearches(false);
    }

    /**
     * <code>characters</code> notifies of character data.
     *
     * @param ch a <code>char []</code> array.
     * @param start an <code>int</code>.
     * @param length an <code>int</code>.
     *
     * @exception SAXException if an error occurs.
     */
    public void characters(char[] ch, int start, int length)
        throws SAXException
    {
        if (bStack.isEmpty())
            return;

        currentBinding = (HandlerBinding) bStack.get(bStack.size() - 1);
        currentBinding.handler.characters(ch, start, length);
    }

    /**
     * <code>getProgram</code> returns the program type which
     * generated the results.
     *
     * @return a <code>String</code> indicating the progam
     * name.
     */
    String getProgram()
    {
        return program;
    }

    /**
     * <code>setProgram</code> informs the adapter which program type
     * it is working on.
     *
     * @param program a <code>String</code> indicating the progam
     * name.
     */
    void setProgram(final String program)
    {
        this.program = program;
    }

    /**
     * <code>inContext</code> returns true if an element is found in
     * the correct context (enclosing element) to be handled. This is
     * used where an element may occur in several places, but should
     * only be handled in a particular context.
     *
     * @param localName a <code>String</code> to check.
     *
     * @return a <code>boolean</code> value.
     */
    private boolean inContext(final String localName)
    {
        // If there is nothing specified for this context we assume it
        // is good
        if (! hContext.keySet().contains(localName))
            return true;

        String requiredContext = (String) hContext.get(localName);

        // Look back down the stack to check that our context is good
        for (int i = bStack.size(); --i > 0;)
        {
            if (((HandlerBinding) bStack.get(i)).name.equals(requiredContext))
                return true;
        }

        return false;
    }
}

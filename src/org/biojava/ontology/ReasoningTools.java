package org.biojava.ontology;

import java.util.Map;
import java.util.Collections;
import java.util.HashMap;

/**
 * Manipulation of Terms that you may well want to do while reasoning.
 *
 * @author Matthew Pocock
 */
public final class ReasoningTools {
  private ReasoningTools() {}

  /**
   * Check two terms for equality. It will take care of imported terms for you.
   *
   * @param a first Term
   * @param b seccond Term
   * @return true if they are equal
   */
  public static boolean areTermsEqual(Term a, Term b)
  {
    //System.out.println("areTermsEqual:\n\t: " + a + "\n\t: " + b);
    a = resolveRemote(a);
    b = resolveRemote(b);

    //System.out.println("areTermsEqual resolved:\n\t: " + a + "\n\t: " + b);

    if(a == b) {
      //System.out.println("areTermsEqual: Identical terms");
      return true;
    }

    if(a instanceof Triple & b instanceof Triple) {
      //System.out.println("areTermsEqual: Triples - calling areTriplesEqual");
      return areTriplesEqual((Triple) a, (Triple) b);
    }

    //System.out.println("Terms are not equal");
    return false;
  }

  /**
   * Decide if two Triple terms are equal. To be equal, they must have equal
   * subject, object and predicate. This takes care of imported terms.
   *
   * @param a the first Triple
   * @param b the seccond Triple
   * @return true if they are equal
   */
  static boolean areTriplesEqual(Triple a, Triple b)
  {
    //System.out.println("areTriplesEqual:\n\t: " + a + "\n\t: " + b);

    if(a == b) {
      //System.out.println("areTriplesEqual: Identical refferences");
      return true;
    }

    if(!areTermsEqual(a.getPredicate(), b.getPredicate())) {
      //System.out.println("areTriplesEqual: different relations");
      return false;
    }

    if(!areTermsEqual(a.getSubject(), b.getSubject())) {
      //System.out.println("areTriplesEqual: different subjects");
      return false;
    }

    if(!areTermsEqual(a.getObject(), b.getObject())) {
      //System.out.println("areTriplesEqual: different objects");
      return false;
    }

    //System.out.println("Same subject, object and predicate");
    return true;
  }

  /**
   * Resolves a term that is potentialy remote to the underlying term.
   *
   * @param t  the Term to resolve
   * @return a Term (guaranteed not to be a RemoteTerm) equal to t
   */
  public static Term resolveRemote(Term t)
  {
    while(t instanceof RemoteTerm) {
      t = ((RemoteTerm) t).getRemoteTerm();
    }

    return t;
  }

  /**
   * Create a new Term by substituting one term for another.
   *
   * <p>
   * If expr is equal to origVal, then newVal is returned. Otherwise, a new
   * Triple is built by calling substitute on the subject, object and predicate.
   * The resulting Term (if a substitution took place) will be generated by
   * calling createVirtualTerm() on dom.
   * </p>
   *
   * @param expr    the original expression
   * @param origVal the original value to substitute
   * @param newVal  the new value to substitute in
   * @param dom     the ReasoningDomain within which scope this takes place
   * @return a Term (possibly a TripleTerm) representing the result of the
   *            substitution
   */
  public static Term substitute(Term expr, Term origVal, Term newVal, ReasoningDomain dom)
  {
    //System.out.println("substitute: expression: " + expr + " origVal: " + origVal + " newVal: " + newVal);
    if(areTermsEqual(expr, origVal)) {
      //System.out.println("substitute: expression and origVal are equal");
      return newVal;
    }

    if(expr instanceof Triple) {
      Triple trip = (Triple) expr;
      Term res = dom.createVirtualTerm(
              substitute(trip.getSubject(), origVal, newVal, dom),
              substitute(trip.getObject(), origVal, newVal, dom),
              substitute(trip.getPredicate(), origVal, newVal, dom),
              null,
              null);
      //System.out.println("substitute: transformed " + expr + " into " + res);
      return res;
    }
    //System.out.println("substitute: not changed " + expr);
    return expr;
  }

  public static Term supportingTriple(Term axiom, Triple proposition, ReasoningDomain rd) {
    if(! (axiom instanceof Triple)) {
      return null;
    }

    Triple ax = (Triple) axiom;

    if(areTermsEqual(axiom, proposition)) {
      return axiom;
    }

    if(resolveRemote(ax.getPredicate()) == OntoTools.IMPLIES) {
      return supportingTriple(ax.getObject(), proposition, rd);
    }

    if(resolveRemote(ax.getPredicate()) == OntoTools.AND) {
      Term st = supportingTriple(ax.getSubject(), proposition, rd);
      Term ot = supportingTriple(ax.getObject(), proposition, rd);

      if(st == null && ot == null) {
        return null;
      }

      if(st == null && ot != null) {
        return st;
      }

      if(ot == null && st != null) {
        return ot;
      }

      if(st == resolveRemote(ax.getSubject())
              && ot == resolveRemote(ax.getObject()))
      {
        return ax;
      }

      return rd.createVirtualTerm(st, ot, OntoTools.AND, null, null);
    }

    return null;
  }

  public static Variable findFirstVariable(Term term)
  {
    term = ReasoningTools.resolveRemote(term);

    if(term instanceof Variable)
      return (Variable) term;

    if(term instanceof Triple) {
      Triple trip = (Triple) term;

      Variable r;

      r = findFirstVariable(trip.getPredicate());
      if(r != null) return r;

      r = findFirstVariable(trip.getSubject());
      if(r != null) return r;

      r = findFirstVariable(trip.getObject());
      if(r != null) return r;
    }

    return null;
  }

  public static Term booleanToTerm(boolean bool) {
    return (bool) ? OntoTools.TRUE : OntoTools.FALSE;
  }

  public static boolean isTrue(Term term) {
    return term == OntoTools.TRUE;
  }

  public static boolean isFalse(Term term) {
    return term == OntoTools.FALSE;
  }

  public static boolean isTruthValue(Term term) {
    return isTrue(term) || isFalse(term);
  }
}
